/*
 * Copyright 2024-2025 The OpenSSL Project Authors. All Rights Reserved.
 *
 * Licensed under the Apache License 2.0 (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 */
{
    -use OpenSSL::paramnames qw(produce_param_decoder);
    -
}

#include <openssl/core_dispatch.h>
#include <openssl/core_names.h>
#include <openssl/params.h>
#include <openssl/err.h>
#include <openssl/proverr.h>
#include <openssl/provider.h>
#include <openssl/rand.h>
#include <openssl/self_test.h>
#include <openssl/param_build.h>
#include <openssl/cms.h>
#include "crypto/hqc_kem.h"
#include "internal/fips.h"
#include "internal/param_build_set.h"
#include "internal/sizes.h"
#include "prov/implementations.h"
#include "prov/providercommon.h"
#include "prov/provider_ctx.h"
#include "prov/securitycheck.h"

static OSSL_FUNC_keymgmt_new_fn hqc_kem_128_new;
static OSSL_FUNC_keymgmt_new_fn hqc_kem_192_new;
static OSSL_FUNC_keymgmt_new_fn hqc_kem_256_new;
static OSSL_FUNC_keymgmt_gen_fn hqc_kem_gen;
static OSSL_FUNC_keymgmt_gen_init_fn hqc_kem_128_gen_init;
static OSSL_FUNC_keymgmt_gen_init_fn hqc_kem_192_gen_init;
static OSSL_FUNC_keymgmt_gen_init_fn hqc_kem_256_gen_init;
static OSSL_FUNC_keymgmt_gen_cleanup_fn hqc_kem_gen_cleanup;
static OSSL_FUNC_keymgmt_gen_set_params_fn hqc_kem_gen_set_params;
static OSSL_FUNC_keymgmt_gen_settable_params_fn hqc_kem_gen_settable_params;
static OSSL_FUNC_keymgmt_get_params_fn hqc_kem_get_params;
static OSSL_FUNC_keymgmt_gettable_params_fn hqc_kem_gettable_params;
static OSSL_FUNC_keymgmt_has_fn hqc_key_has;
static OSSL_FUNC_keymgmt_match_fn hqc_key_match;
static OSSL_FUNC_keymgmt_validate_fn hqc_kem_validate;
static OSSL_FUNC_keymgmt_import_fn hqc_kem_import;
static OSSL_FUNC_keymgmt_export_fn hqc_key_export;
static OSSL_FUNC_keymgmt_import_types_fn hqc_kem_imexport_types;
static OSSL_FUNC_keymgmt_export_types_fn hqc_kem_imexport_types;
static OSSL_FUNC_keymgmt_dup_fn hqc_kem_dup;

static int xof_get_bytes(EVP_MD_CTX *xof_ctx, uint8_t *output, uint32_t output_size);
/**
 * @def HQC_PRNG_DOMAIN_SEP
 * @brief Domain separation constant for the HQC PRNG (Pseudo-Random
 *        Number Generator).
 *
 * Used to distinguish the PRNG context from other cryptographic
 * primitives in HQC operations, ensuring unique input domains for
 * hashing or seed expansion functions.
 */
#define HQC_PRNG_DOMAIN_SEP 0

/**
 * @def HQC_XOF_SEP
 * @brief Domain separation constant for the HQC XOF (eXtendable Output
 *        Function).
 *
 * Ensures that XOF operations are cryptographically independent from
 * PRNG and other HQC domains by providing a unique separation value.
 */
#define HQC_XOF_SEP 1

/**
 * @def HQC_I_DOMAIN_SEP
 * @brief Domain separation constant for HQC intermediate computations.
 *
 * Used to separate internal or intermediate values from other HQC
 * function domains, preventing collisions or cross-domain reuse of
 * data in cryptographic processes.
 */
#define HQC_I_DOMAIN_SEP 2

/**
 * @def KARATSUBA_THRESHOLD
 * @brief Threshold for switching to the Karatsuba multiplication
 *        algorithm.
 *
 * When the operand size (in coefficients, words, or bits—depending on
 * context) exceeds this threshold, the Karatsuba multiplication method
 * is used instead of the standard (schoolbook) multiplication.
 *
 * This value balances performance and overhead: smaller sizes use
 * simpler algorithms to reduce setup cost, while larger sizes benefit
 * from Karatsuba’s reduced asymptotic complexity.
 */
#define KARATSUBA_THRESHOLD 16

static const uint16_t hqc_1_rs_coefs[] = { 89, 69, 153, 116, 176, 117, 111, 75, 73,
    233, 242, 233, 65, 210, 21, 139, 103, 173,
    67, 118, 105, 210, 174, 110, 74, 69, 228,
    82, 255, 181, 1 };
static const uint16_t hqc_3_rs_coefs[] = { 45, 216, 239, 24, 253, 104, 27, 40, 107, 50,
    163, 210, 227, 134, 224, 158, 119, 13, 158,
    1, 238, 164, 82, 43, 15, 232, 246, 142, 50,
    189, 29, 232, 1 };
static const uint16_t hqc_5_rs_coefs[] = { 49, 167, 49, 39, 200, 121, 124, 91, 240, 63, 148, 71,
    150, 123, 87, 101, 32, 215, 159, 71, 201, 115, 97,
    210, 186, 183, 141, 217, 123, 12, 31, 243, 180, 219,
    152, 239, 99, 141, 4, 246, 191, 144, 8, 232, 47, 27,
    141, 178, 130, 64, 124, 47, 39, 188, 216, 48, 199, 187, 1 };

static const uint16_t hqc_1_alpha_ij_pow[30][45] = {
    { 2, 4, 8, 16, 32, 64, 128, 29, 58, 116, 232, 205, 135, 19, 38, 76, 152, 45, 90, 180, 117, 234, 201,
        143, 3, 6, 12, 24, 48, 96, 192, 157, 39, 78, 156, 37, 74, 148, 53, 106, 212, 181, 119, 238, 193 },
    { 4, 16, 64, 29, 116, 205, 19, 76, 45, 180, 234, 143, 6, 24, 96, 157, 78, 37, 148, 106, 181, 238, 159,
        70, 5, 20, 80, 93, 105, 185, 222, 95, 97, 153, 94, 101, 137, 30, 120, 253, 211, 107, 177, 254, 223 },
    { 8, 64, 58, 205, 38, 45, 117, 143, 12, 96, 39, 37, 53, 181, 193, 70, 10, 80, 186, 185, 161, 97, 47,
        101, 15, 120, 231, 107, 127, 223, 182, 217, 134, 68, 26, 208, 206, 62, 237, 59, 197, 102, 23, 184, 169 },
    { 16, 29, 205, 76, 180, 143, 24, 157, 37, 106, 238, 70, 20, 93, 185, 95, 153, 101, 30, 253, 107, 254, 91,
        217, 17, 13, 208, 129, 248, 59, 151, 133, 184, 79, 132, 168, 82, 73, 228, 230, 198, 252, 123, 227, 150 },
    { 32, 116, 38, 180, 3, 96, 156, 106, 193, 5, 160, 185, 190, 94, 15, 253, 214, 223, 226, 17, 26, 103, 124,
        59, 51, 46, 169, 132, 77, 85, 114, 230, 145, 215, 255, 150, 55, 174, 100, 28, 167, 89, 239, 172, 36 },
    { 64, 205, 45, 143, 96, 37, 181, 70, 80, 185, 97, 101, 120, 107, 223, 217, 68, 208, 62, 59, 102, 184, 33,
        168, 85, 228, 191, 252, 241, 150, 110, 130, 7, 221, 89, 195, 138, 61, 251, 44, 207, 173, 8, 58, 38 },
    { 128, 19, 117, 24, 156, 181, 140, 93, 161, 94, 60, 107, 163, 67, 26, 129, 147, 102, 109, 132, 41, 57, 209,
        252, 255, 98, 87, 200, 224, 89, 155, 18, 245, 11, 233, 173, 16, 232, 45, 3, 157, 53, 159, 40, 185 },
    { 29, 76, 143, 157, 106, 70, 93, 95, 101, 253, 254, 217, 13, 129, 59, 133, 79, 168, 73, 230, 252, 227, 149,
        130, 28, 81, 195, 18, 247, 44, 27, 2, 58, 152, 3, 39, 212, 140, 186, 190, 202, 231, 225, 175, 26 },
    { 58, 45, 12, 37, 193, 80, 161, 101, 231, 223, 134, 208, 237, 102, 169, 168, 146, 191, 179, 150, 87, 7, 166,
        195, 36, 251, 125, 173, 64, 38, 143, 39, 181, 10, 185, 47, 120, 127, 217, 26, 62, 197, 184, 21, 85 },
    { 116, 180, 96, 106, 5, 185, 94, 253, 223, 17, 103, 59, 46, 132, 85, 230, 215, 150, 174, 28, 89, 172, 244,
        44, 108, 32, 38, 3, 156, 193, 160, 190, 15, 214, 226, 26, 124, 51, 169, 77, 114, 145, 255, 55, 100 },
    { 232, 234, 39, 238, 160, 97, 60, 254, 134, 103, 118, 184, 84, 57, 145, 227, 220, 7, 162, 172, 245, 176, 71,
        58, 180, 192, 181, 40, 95, 15, 177, 175, 208, 147, 46, 21, 73, 99, 241, 55, 200, 166, 43, 122, 44 },
    { 205, 143, 37, 70, 185, 101, 107, 217, 208, 59, 184, 168, 228, 252, 150, 130, 221, 195, 61, 44, 173, 58, 117,
        39, 193, 186, 47, 231, 182, 26, 237, 23, 21, 146, 145, 219, 87, 56, 242, 36, 139, 54, 64, 45, 96 },
    { 135, 6, 53, 20, 190, 120, 163, 13, 237, 46, 84, 228, 229, 98, 100, 81, 69, 251, 131, 32, 45, 192, 238,
        186, 94, 187, 217, 189, 236, 169, 82, 209, 241, 220, 28, 242, 72, 22, 173, 116, 201, 37, 140, 222, 15 },
    { 19, 24, 181, 93, 94, 107, 67, 129, 102, 132, 57, 252, 98, 200, 89, 18, 11, 173, 232, 3, 53, 40, 194,
        231, 226, 189, 197, 158, 170, 145, 75, 25, 166, 69, 235, 54, 29, 234, 37, 5, 95, 120, 91, 52, 59 },
    { 38, 96, 193, 185, 15, 223, 26, 59, 169, 85, 145, 150, 100, 89, 36, 44, 1, 38, 96, 193, 185, 15, 223,
        26, 59, 169, 85, 145, 150, 100, 89, 36, 44, 1, 38, 96, 193, 185, 15, 223, 26, 59, 169, 85, 145 },
    { 76, 157, 70, 95, 253, 217, 129, 133, 168, 230, 227, 130, 81, 18, 44, 2, 152, 39, 140, 190, 231, 175, 31,
        23, 77, 209, 219, 25, 162, 36, 88, 4, 45, 78, 5, 97, 211, 67, 62, 46, 154, 191, 171, 50, 89 },
    { 152, 78, 10, 153, 214, 68, 147, 79, 146, 215, 220, 221, 69, 11, 1, 152, 78, 10, 153, 214, 68, 147, 79,
        146, 215, 220, 221, 69, 11, 1, 152, 78, 10, 153, 214, 68, 147, 79, 146, 215, 220, 221, 69, 11, 1 },
    { 45, 37, 80, 101, 223, 208, 102, 168, 191, 150, 7, 195, 251, 173, 38, 39, 10, 47, 127, 26, 197, 21, 115,
        219, 100, 242, 245, 54, 205, 96, 70, 97, 107, 68, 59, 33, 228, 241, 130, 89, 61, 207, 58, 12, 193 },
    { 90, 148, 186, 30, 226, 62, 109, 73, 179, 174, 162, 61, 131, 232, 96, 140, 153, 127, 52, 51, 168, 99, 98,
        56, 172, 22, 8, 234, 212, 185, 240, 67, 237, 79, 114, 241, 25, 121, 245, 108, 19, 39, 20, 188, 223 },
    { 180, 106, 185, 253, 17, 59, 132, 230, 150, 28, 172, 44, 32, 3, 193, 190, 214, 26, 51, 77, 145, 55, 167,
        36, 233, 116, 96, 5, 94, 223, 103, 46, 85, 215, 174, 89, 244, 108, 38, 156, 160, 15, 226, 124, 169 },
    { 117, 181, 161, 107, 26, 102, 41, 252, 87, 89, 245, 173, 45, 53, 185, 231, 68, 197, 168, 145, 110, 166, 61,
        54, 38, 37, 186, 120, 134, 59, 21, 191, 196, 221, 36, 207, 205, 39, 80, 15, 217, 237, 33, 115, 150 },
    { 234, 238, 97, 254, 103, 184, 57, 227, 7, 172, 176, 58, 192, 40, 15, 175, 147, 21, 99, 55, 166, 122, 216,
        45, 106, 222, 107, 52, 133, 85, 123, 50, 195, 11, 32, 12, 140, 188, 182, 124, 158, 115, 49, 224, 36 },
    { 201, 159, 47, 91, 124, 33, 209, 149, 166, 244, 71, 117, 238, 194, 223, 31, 79, 115, 98, 167, 61, 216, 90,
        181, 190, 254, 206, 218, 213, 150, 224, 72, 54, 152, 106, 161, 177, 189, 184, 114, 171, 56, 18, 131, 38 },
    { 143, 70, 101, 217, 59, 168, 252, 130, 195, 44, 58, 39, 186, 231, 26, 23, 146, 219, 56, 36, 54, 45, 181,
        97, 223, 62, 33, 191, 110, 89, 251, 8, 12, 10, 15, 134, 197, 41, 179, 100, 86, 125, 205, 37, 185 },
    { 3, 5, 15, 17, 51, 85, 255, 28, 36, 108, 180, 193, 94, 226, 59, 77, 215, 100, 172, 233, 38, 106, 190,
        223, 124, 132, 145, 174, 239, 44, 116, 156, 185, 214, 103, 169, 230, 55, 89, 235, 32, 96, 160, 253, 26 },
    { 6, 20, 120, 13, 46, 228, 98, 81, 251, 32, 192, 186, 187, 189, 169, 209, 220, 242, 22, 116, 37, 222, 254,
        62, 132, 63, 130, 43, 250, 38, 212, 194, 182, 147, 77, 179, 141, 9, 54, 180, 159, 101, 67, 151, 85 },
    { 12, 80, 231, 208, 169, 191, 87, 195, 125, 38, 181, 47, 217, 197, 85, 219, 221, 245, 8, 96, 186, 107, 206,
        33, 145, 130, 86, 207, 45, 193, 101, 134, 102, 146, 150, 166, 251, 64, 39, 185, 127, 62, 21, 252, 100 },
    { 24, 93, 107, 129, 132, 252, 200, 18, 173, 3, 40, 231, 189, 158, 145, 25, 69, 54, 234, 5, 120, 52, 218,
        191, 174, 43, 207, 90, 35, 15, 136, 92, 115, 220, 239, 125, 76, 238, 101, 17, 133, 228, 149, 121, 44 },
    { 48, 105, 127, 248, 77, 241, 224, 247, 64, 156, 95, 182, 236, 170, 150, 162, 11, 205, 212, 94, 134, 133, 213,
        110, 239, 250, 45, 35, 30, 26, 218, 99, 130, 69, 108, 143, 40, 211, 206, 132, 229, 7, 144, 2, 96 },
    { 96, 185, 223, 59, 85, 150, 89, 44, 38, 193, 15, 26, 169, 145, 100, 36, 1, 96, 185, 223, 59, 85, 150,
        89, 44, 38, 193, 15, 26, 169, 145, 100, 36, 1, 96, 185, 223, 59, 85, 150, 89, 44, 38, 193, 15 }
};

static const uint16_t hqc_3_alpha_ij_pow[32][55] = {
    { 2, 4, 8, 16, 32, 64, 128, 29, 58, 116, 232, 205, 135, 19, 38, 76, 152, 45, 90,
        180, 117, 234, 201, 143, 3, 6, 12, 24, 48, 96, 192, 157, 39, 78, 156, 37, 74, 148,
        53, 106, 212, 181, 119, 238, 193, 159, 35, 70, 140, 5, 10, 20, 40, 80, 160 },
    { 4, 16, 64, 29, 116, 205, 19, 76, 45, 180, 234, 143, 6, 24, 96, 157, 78, 37, 148,
        106, 181, 238, 159, 70, 5, 20, 80, 93, 105, 185, 222, 95, 97, 153, 94, 101, 137, 30,
        120, 253, 211, 107, 177, 254, 223, 91, 113, 217, 67, 17, 68, 13, 52, 208, 103 },
    { 8, 64, 58, 205, 38, 45, 117, 143, 12, 96, 39, 37, 53, 181, 193, 70, 10, 80, 186,
        185, 161, 97, 47, 101, 15, 120, 231, 107, 127, 223, 182, 217, 134, 68, 26, 208, 206, 62,
        237, 59, 197, 102, 23, 184, 169, 33, 21, 168, 41, 85, 146, 228, 115, 191, 145 },
    { 16, 29, 205, 76, 180, 143, 24, 157, 37, 106, 238, 70, 20, 93, 185, 95, 153, 101, 30,
        253, 107, 254, 91, 217, 17, 13, 208, 129, 248, 59, 151, 133, 184, 79, 132, 168, 82, 73,
        228, 230, 198, 252, 123, 227, 150, 149, 165, 130, 200, 28, 221, 81, 121, 195, 172 },
    { 32, 116, 38, 180, 3, 96, 156, 106, 193, 5, 160, 185, 190, 94, 15, 253, 214, 223, 226,
        17, 26, 103, 124, 59, 51, 46, 169, 132, 77, 85, 114, 230, 145, 215, 255, 150, 55, 174,
        100, 28, 167, 89, 239, 172, 36, 244, 235, 44, 233, 108, 1, 32, 116, 38, 180 },
    { 64, 205, 45, 143, 96, 37, 181, 70, 80, 185, 97, 101, 120, 107, 223, 217, 68, 208, 62,
        59, 102, 184, 33, 168, 85, 228, 191, 252, 241, 150, 110, 130, 7, 221, 89, 195, 138, 61,
        251, 44, 207, 173, 8, 58, 38, 117, 12, 39, 53, 193, 10, 186, 161, 47, 15 },
    { 128, 19, 117, 24, 156, 181, 140, 93, 161, 94, 60, 107, 163, 67, 26, 129, 147, 102, 109,
        132, 41, 57, 209, 252, 255, 98, 87, 200, 224, 89, 155, 18, 245, 11, 233, 173, 16, 232,
        45, 3, 157, 53, 159, 40, 185, 194, 137, 231, 254, 226, 68, 189, 248, 197, 46 },
    { 29, 76, 143, 157, 106, 70, 93, 95, 101, 253, 254, 217, 13, 129, 59, 133, 79, 168, 73,
        230, 252, 227, 149, 130, 28, 81, 195, 18, 247, 44, 27, 2, 58, 152, 3, 39, 212, 140,
        186, 190, 202, 231, 225, 175, 26, 31, 118, 23, 158, 77, 146, 209, 229, 219, 55 },
    { 58, 45, 12, 37, 193, 80, 161, 101, 231, 223, 134, 208, 237, 102, 169, 168, 146, 191, 179,
        150, 87, 7, 166, 195, 36, 251, 125, 173, 64, 38, 143, 39, 181, 10, 185, 47, 120, 127,
        217, 26, 62, 197, 184, 21, 85, 115, 252, 219, 110, 100, 221, 242, 138, 245, 44 },
    { 116, 180, 96, 106, 5, 185, 94, 253, 223, 17, 103, 59, 46, 132, 85, 230, 215, 150, 174,
        28, 89, 172, 244, 44, 108, 32, 38, 3, 156, 193, 160, 190, 15, 214, 226, 26, 124, 51,
        169, 77, 114, 145, 255, 55, 100, 167, 239, 36, 235, 233, 1, 116, 180, 96, 106 },
    { 232, 234, 39, 238, 160, 97, 60, 254, 134, 103, 118, 184, 84, 57, 145, 227, 220, 7, 162,
        172, 245, 176, 71, 58, 180, 192, 181, 40, 95, 15, 177, 175, 208, 147, 46, 21, 73, 99,
        241, 55, 200, 166, 43, 122, 44, 216, 128, 45, 48, 106, 10, 222, 202, 107, 226 },
    { 205, 143, 37, 70, 185, 101, 107, 217, 208, 59, 184, 168, 228, 252, 150, 130, 221, 195, 61,
        44, 173, 58, 117, 39, 193, 186, 47, 231, 182, 26, 237, 23, 21, 146, 145, 219, 87, 56,
        242, 36, 139, 54, 64, 45, 96, 181, 80, 97, 120, 223, 68, 62, 102, 33, 85 },
    { 135, 6, 53, 20, 190, 120, 163, 13, 237, 46, 84, 228, 229, 98, 100, 81, 69, 251, 131,
        32, 45, 192, 238, 186, 94, 187, 217, 189, 236, 169, 82, 209, 241, 220, 28, 242, 72, 22,
        173, 116, 201, 37, 140, 222, 15, 254, 34, 62, 204, 132, 146, 63, 75, 130, 167 },
    { 19, 24, 181, 93, 94, 107, 67, 129, 102, 132, 57, 252, 98, 200, 89, 18, 11, 173, 232,
        3, 53, 40, 194, 231, 226, 189, 197, 158, 170, 145, 75, 25, 166, 69, 235, 54, 29, 234,
        37, 5, 95, 120, 91, 52, 59, 218, 82, 191, 227, 174, 221, 43, 247, 207, 32 },
    { 38, 96, 193, 185, 15, 223, 26, 59, 169, 85, 145, 150, 100, 89, 36, 44, 1, 38, 96,
        193, 185, 15, 223, 26, 59, 169, 85, 145, 150, 100, 89, 36, 44, 1, 38, 96, 193, 185,
        15, 223, 26, 59, 169, 85, 145, 150, 100, 89, 36, 44, 1, 38, 96, 193, 185 },
    { 76, 157, 70, 95, 253, 217, 129, 133, 168, 230, 227, 130, 81, 18, 44, 2, 152, 39, 140,
        190, 231, 175, 31, 23, 77, 209, 219, 25, 162, 36, 88, 4, 45, 78, 5, 97, 211, 67,
        62, 46, 154, 191, 171, 50, 89, 72, 176, 8, 90, 156, 10, 194, 187, 134, 124 },
    { 152, 78, 10, 153, 214, 68, 147, 79, 146, 215, 220, 221, 69, 11, 1, 152, 78, 10, 153,
        214, 68, 147, 79, 146, 215, 220, 221, 69, 11, 1, 152, 78, 10, 153, 214, 68, 147, 79,
        146, 215, 220, 221, 69, 11, 1, 152, 78, 10, 153, 214, 68, 147, 79, 146, 215 },
    { 45, 37, 80, 101, 223, 208, 102, 168, 191, 150, 7, 195, 251, 173, 38, 39, 10, 47, 127,
        26, 197, 21, 115, 219, 100, 242, 245, 54, 205, 96, 70, 97, 107, 68, 59, 33, 228, 241,
        130, 89, 61, 207, 58, 12, 193, 161, 231, 134, 237, 169, 146, 179, 87, 166, 36 },
    { 90, 148, 186, 30, 226, 62, 109, 73, 179, 174, 162, 61, 131, 232, 96, 140, 153, 127, 52,
        51, 168, 99, 98, 56, 172, 22, 8, 234, 212, 185, 240, 67, 237, 79, 114, 241, 25, 121,
        245, 108, 19, 39, 20, 188, 223, 189, 133, 41, 63, 55, 221, 9, 176, 64, 3 },
    { 180, 106, 185, 253, 17, 59, 132, 230, 150, 28, 172, 44, 32, 3, 193, 190, 214, 26, 51,
        77, 145, 55, 167, 36, 233, 116, 96, 5, 94, 223, 103, 46, 85, 215, 174, 89, 244, 108,
        38, 156, 160, 15, 226, 124, 169, 114, 255, 100, 239, 235, 1, 180, 106, 185, 253 },
    { 117, 181, 161, 107, 26, 102, 41, 252, 87, 89, 245, 173, 45, 53, 185, 231, 68, 197, 168,
        145, 110, 166, 61, 54, 38, 37, 186, 120, 134, 59, 21, 191, 196, 221, 36, 207, 205, 39,
        80, 15, 217, 237, 33, 115, 150, 56, 138, 125, 58, 96, 10, 101, 182, 62, 169 },
    { 234, 238, 97, 254, 103, 184, 57, 227, 7, 172, 176, 58, 192, 40, 15, 175, 147, 21, 99,
        55, 166, 122, 216, 45, 106, 222, 107, 52, 133, 85, 123, 50, 195, 11, 32, 12, 140, 188,
        182, 124, 158, 115, 49, 224, 36, 131, 19, 37, 105, 253, 68, 151, 154, 252, 174 },
    { 201, 159, 47, 91, 124, 33, 209, 149, 166, 244, 71, 117, 238, 194, 223, 31, 79, 115, 98,
        167, 61, 216, 90, 181, 190, 254, 206, 218, 213, 150, 224, 72, 54, 152, 106, 161, 177, 189,
        184, 114, 171, 56, 18, 131, 38, 148, 111, 107, 104, 46, 146, 227, 14, 138, 233 },
    { 143, 70, 101, 217, 59, 168, 252, 130, 195, 44, 58, 39, 186, 231, 26, 23, 146, 219, 56,
        36, 54, 45, 181, 97, 223, 62, 33, 191, 110, 89, 251, 8, 12, 10, 15, 134, 197, 41,
        179, 100, 86, 125, 205, 37, 185, 107, 208, 184, 228, 150, 221, 61, 173, 117, 193 },
    { 3, 5, 15, 17, 51, 85, 255, 28, 36, 108, 180, 193, 94, 226, 59, 77, 215, 100, 172,
        233, 38, 106, 190, 223, 124, 132, 145, 174, 239, 44, 116, 156, 185, 214, 103, 169, 230, 55,
        89, 235, 32, 96, 160, 253, 26, 46, 114, 150, 167, 244, 1, 3, 5, 15, 17 },
    { 6, 20, 120, 13, 46, 228, 98, 81, 251, 32, 192, 186, 187, 189, 169, 209, 220, 242, 22,
        116, 37, 222, 254, 62, 132, 63, 130, 43, 250, 38, 212, 194, 182, 147, 77, 179, 141, 9,
        54, 180, 159, 101, 67, 151, 85, 227, 112, 61, 142, 3, 10, 60, 136, 23, 114 },
    { 12, 80, 231, 208, 169, 191, 87, 195, 125, 38, 181, 47, 217, 197, 85, 219, 221, 245, 8,
        96, 186, 107, 206, 33, 145, 130, 86, 207, 45, 193, 101, 134, 102, 146, 150, 166, 251, 64,
        39, 185, 127, 62, 21, 252, 100, 138, 54, 117, 70, 15, 68, 23, 228, 196, 89 },
    { 24, 93, 107, 129, 132, 252, 200, 18, 173, 3, 40, 231, 189, 158, 145, 25, 69, 54, 234,
        5, 120, 52, 218, 191, 174, 43, 207, 90, 35, 15, 136, 92, 115, 220, 239, 125, 76, 238,
        101, 17, 133, 228, 149, 121, 44, 135, 212, 47, 175, 51, 146, 49, 162, 139, 116 },
    { 48, 105, 127, 248, 77, 241, 224, 247, 64, 156, 95, 182, 236, 170, 150, 162, 11, 205, 212,
        94, 134, 133, 213, 110, 239, 250, 45, 35, 30, 26, 218, 99, 130, 69, 108, 143, 40, 211,
        206, 132, 229, 7, 144, 2, 96, 210, 254, 237, 154, 255, 221, 243, 128, 37, 190 },
    { 96, 185, 223, 59, 85, 150, 89, 44, 38, 193, 15, 26, 169, 145, 100, 36, 1, 96, 185,
        223, 59, 85, 150, 89, 44, 38, 193, 15, 26, 169, 145, 100, 36, 1, 96, 185, 223, 59,
        85, 150, 89, 44, 38, 193, 15, 26, 169, 145, 100, 36, 1, 96, 185, 223, 59 },
    { 192, 222, 182, 151, 114, 110, 155, 27, 143, 160, 177, 237, 82, 75, 89, 88, 152, 70, 240,
        103, 21, 123, 224, 251, 116, 212, 101, 136, 218, 145, 200, 144, 8, 78, 190, 217, 204, 183,
        87, 172, 216, 12, 105, 225, 59, 170, 98, 242, 250, 180, 10, 211, 31, 168, 255 },
    { 157, 95, 217, 133, 230, 130, 18, 2, 39, 190, 175, 23, 209, 25, 36, 4, 78, 97, 67,
        46, 191, 50, 72, 8, 156, 194, 134, 92, 99, 100, 144, 16, 37, 153, 17, 184, 198, 200,
        61, 32, 74, 47, 34, 109, 145, 141, 122, 64, 148, 94, 68, 218, 63, 7, 244 }
};

static const uint16_t hqc_5_alpha_ij_pow[58][89] = {
    { 2, 4, 8, 16, 32, 64, 128, 29, 58, 116, 232, 205, 135, 19, 38, 76, 152, 45, 90, 180, 117, 234, 201,
        143, 3, 6, 12, 24, 48, 96, 192, 157, 39, 78, 156, 37, 74, 148, 53, 106, 212, 181, 119, 238, 193, 159,
        35, 70, 140, 5, 10, 20, 40, 80, 160, 93, 186, 105, 210, 185, 111, 222, 161, 95, 190, 97, 194, 153, 47,
        94, 188, 101, 202, 137, 15, 30, 60, 120, 240, 253, 231, 211, 187, 107, 214, 177, 127, 254, 225 },
    { 4, 16, 64, 29, 116, 205, 19, 76, 45, 180, 234, 143, 6, 24, 96, 157, 78, 37, 148, 106, 181, 238, 159,
        70, 5, 20, 80, 93, 105, 185, 222, 95, 97, 153, 94, 101, 137, 30, 120, 253, 211, 107, 177, 254, 223, 91,
        113, 217, 67, 17, 68, 13, 52, 208, 103, 129, 62, 248, 199, 59, 236, 151, 102, 133, 46, 184, 218, 79, 33,
        132, 42, 168, 154, 82, 85, 73, 57, 228, 183, 230, 191, 198, 63, 252, 215, 123, 241, 227, 171 },
    { 8, 64, 58, 205, 38, 45, 117, 143, 12, 96, 39, 37, 53, 181, 193, 70, 10, 80, 186, 185, 161, 97, 47,
        101, 15, 120, 231, 107, 127, 223, 182, 217, 134, 68, 26, 208, 206, 62, 237, 59, 197, 102, 23, 184, 169, 33,
        21, 168, 41, 85, 146, 228, 115, 191, 145, 252, 179, 241, 219, 150, 196, 110, 87, 130, 100, 7, 56, 221, 166,
        89, 242, 195, 86, 138, 36, 61, 245, 251, 139, 44, 125, 207, 54, 173, 1, 8, 64, 58, 205 },
    { 16, 29, 205, 76, 180, 143, 24, 157, 37, 106, 238, 70, 20, 93, 185, 95, 153, 101, 30, 253, 107, 254, 91,
        217, 17, 13, 208, 129, 248, 59, 151, 133, 184, 79, 132, 168, 82, 73, 228, 230, 198, 252, 123, 227, 150, 149,
        165, 130, 200, 28, 221, 81, 121, 195, 172, 18, 61, 247, 203, 44, 250, 27, 173, 2, 32, 58, 135, 152, 117,
        3, 48, 39, 74, 212, 193, 140, 40, 186, 111, 190, 47, 202, 60, 231, 214, 225, 182, 175, 34 },
    { 32, 116, 38, 180, 3, 96, 156, 106, 193, 5, 160, 185, 190, 94, 15, 253, 214, 223, 226, 17, 26, 103, 124,
        59, 51, 46, 169, 132, 77, 85, 114, 230, 145, 215, 255, 150, 55, 174, 100, 28, 167, 89, 239, 172, 36, 244,
        235, 44, 233, 108, 1, 32, 116, 38, 180, 3, 96, 156, 106, 193, 5, 160, 185, 190, 94, 15, 253, 214, 223,
        226, 17, 26, 103, 124, 59, 51, 46, 169, 132, 77, 85, 114, 230, 145, 215, 255, 150, 55, 174 },
    { 64, 205, 45, 143, 96, 37, 181, 70, 80, 185, 97, 101, 120, 107, 223, 217, 68, 208, 62, 59, 102, 184, 33,
        168, 85, 228, 191, 252, 241, 150, 110, 130, 7, 221, 89, 195, 138, 61, 251, 44, 207, 173, 8, 58, 38, 117,
        12, 39, 53, 193, 10, 186, 161, 47, 15, 231, 127, 182, 134, 26, 206, 237, 197, 23, 169, 21, 41, 146, 115,
        145, 179, 219, 196, 87, 100, 56, 166, 242, 86, 36, 245, 139, 125, 54, 1, 64, 205, 45, 143 },
    { 128, 19, 117, 24, 156, 181, 140, 93, 161, 94, 60, 107, 163, 67, 26, 129, 147, 102, 109, 132, 41, 57, 209,
        252, 255, 98, 87, 200, 224, 89, 155, 18, 245, 11, 233, 173, 16, 232, 45, 3, 157, 53, 159, 40, 185, 194,
        137, 231, 254, 226, 68, 189, 248, 197, 46, 158, 168, 170, 183, 145, 123, 75, 110, 25, 28, 166, 249, 69, 61,
        235, 176, 54, 2, 29, 38, 234, 48, 37, 119, 5, 186, 95, 188, 120, 214, 91, 134, 52, 31 },
    { 29, 76, 143, 157, 106, 70, 93, 95, 101, 253, 254, 217, 13, 129, 59, 133, 79, 168, 73, 230, 252, 227, 149,
        130, 28, 81, 195, 18, 247, 44, 27, 2, 58, 152, 3, 39, 212, 140, 186, 190, 202, 231, 225, 175, 26, 31,
        118, 23, 158, 77, 146, 209, 229, 219, 55, 25, 56, 162, 155, 36, 243, 88, 54, 4, 116, 45, 6, 78, 181,
        5, 105, 97, 137, 211, 223, 67, 52, 62, 236, 46, 33, 154, 57, 191, 215, 171, 110, 50, 112 },
    { 58, 45, 12, 37, 193, 80, 161, 101, 231, 223, 134, 208, 237, 102, 169, 168, 146, 191, 179, 150, 87, 7, 166,
        195, 36, 251, 125, 173, 64, 38, 143, 39, 181, 10, 185, 47, 120, 127, 217, 26, 62, 197, 184, 21, 85, 115,
        252, 219, 110, 100, 221, 242, 138, 245, 44, 54, 8, 205, 117, 96, 53, 70, 186, 97, 15, 107, 182, 68, 206,
        59, 23, 33, 41, 228, 145, 241, 196, 130, 56, 89, 86, 61, 139, 207, 1, 58, 45, 12, 37 },
    { 116, 180, 96, 106, 5, 185, 94, 253, 223, 17, 103, 59, 46, 132, 85, 230, 215, 150, 174, 28, 89, 172, 244,
        44, 108, 32, 38, 3, 156, 193, 160, 190, 15, 214, 226, 26, 124, 51, 169, 77, 114, 145, 255, 55, 100, 167,
        239, 36, 235, 233, 1, 116, 180, 96, 106, 5, 185, 94, 253, 223, 17, 103, 59, 46, 132, 85, 230, 215, 150,
        174, 28, 89, 172, 244, 44, 108, 32, 38, 3, 156, 193, 160, 190, 15, 214, 226, 26, 124, 51 },
    { 232, 234, 39, 238, 160, 97, 60, 254, 134, 103, 118, 184, 84, 57, 145, 227, 220, 7, 162, 172, 245, 176, 71,
        58, 180, 192, 181, 40, 95, 15, 177, 175, 208, 147, 46, 21, 73, 99, 241, 55, 200, 166, 43, 122, 44, 216,
        128, 45, 48, 106, 10, 222, 202, 107, 226, 52, 237, 133, 66, 85, 209, 123, 196, 50, 167, 195, 144, 11, 54,
        32, 76, 12, 148, 140, 185, 188, 211, 182, 13, 124, 102, 158, 82, 115, 215, 49, 130, 224, 249 },
    { 205, 143, 37, 70, 185, 101, 107, 217, 208, 59, 184, 168, 228, 252, 150, 130, 221, 195, 61, 44, 173, 58, 117,
        39, 193, 186, 47, 231, 182, 26, 237, 23, 21, 146, 145, 219, 87, 56, 242, 36, 139, 54, 64, 45, 96, 181,
        80, 97, 120, 223, 68, 62, 102, 33, 85, 191, 241, 110, 7, 89, 138, 251, 207, 8, 38, 12, 53, 10, 161,
        15, 127, 134, 206, 197, 169, 41, 115, 179, 196, 100, 166, 86, 245, 125, 1, 205, 143, 37, 70 },
    { 135, 6, 53, 20, 190, 120, 163, 13, 237, 46, 84, 228, 229, 98, 100, 81, 69, 251, 131, 32, 45, 192, 238,
        186, 94, 187, 217, 189, 236, 169, 82, 209, 241, 220, 28, 242, 72, 22, 173, 116, 201, 37, 140, 222, 15, 254,
        34, 62, 204, 132, 146, 63, 75, 130, 167, 43, 245, 250, 4, 38, 24, 212, 80, 194, 253, 182, 52, 147, 184,
        77, 183, 179, 149, 141, 89, 9, 203, 54, 128, 180, 39, 159, 210, 101, 214, 67, 206, 151, 158 },
    { 19, 24, 181, 93, 94, 107, 67, 129, 102, 132, 57, 252, 98, 200, 89, 18, 11, 173, 232, 3, 53, 40, 194,
        231, 226, 189, 197, 158, 170, 145, 75, 25, 166, 69, 235, 54, 29, 234, 37, 5, 95, 120, 91, 52, 59, 218,
        82, 191, 227, 174, 221, 43, 247, 207, 32, 90, 39, 35, 111, 15, 225, 136, 237, 92, 77, 115, 246, 220, 56,
        239, 122, 125, 4, 76, 96, 238, 105, 101, 177, 17, 62, 133, 42, 228, 215, 149, 7, 121, 72 },
    { 38, 96, 193, 185, 15, 223, 26, 59, 169, 85, 145, 150, 100, 89, 36, 44, 1, 38, 96, 193, 185, 15, 223,
        26, 59, 169, 85, 145, 150, 100, 89, 36, 44, 1, 38, 96, 193, 185, 15, 223, 26, 59, 169, 85, 145, 150,
        100, 89, 36, 44, 1, 38, 96, 193, 185, 15, 223, 26, 59, 169, 85, 145, 150, 100, 89, 36, 44, 1, 38,
        96, 193, 185, 15, 223, 26, 59, 169, 85, 145, 150, 100, 89, 36, 44, 1, 38, 96, 193, 185 },
    { 76, 157, 70, 95, 253, 217, 129, 133, 168, 230, 227, 130, 81, 18, 44, 2, 152, 39, 140, 190, 231, 175, 31,
        23, 77, 209, 219, 25, 162, 36, 88, 4, 45, 78, 5, 97, 211, 67, 62, 46, 154, 191, 171, 50, 89, 72,
        176, 8, 90, 156, 10, 194, 187, 134, 124, 92, 41, 99, 75, 100, 178, 144, 125, 16, 180, 37, 20, 153, 107,
        17, 248, 184, 82, 198, 150, 200, 121, 61, 250, 32, 117, 74, 40, 47, 214, 34, 237, 109, 164 },
    { 152, 78, 10, 153, 214, 68, 147, 79, 146, 215, 220, 221, 69, 11, 1, 152, 78, 10, 153, 214, 68, 147, 79,
        146, 215, 220, 221, 69, 11, 1, 152, 78, 10, 153, 214, 68, 147, 79, 146, 215, 220, 221, 69, 11, 1, 152,
        78, 10, 153, 214, 68, 147, 79, 146, 215, 220, 221, 69, 11, 1, 152, 78, 10, 153, 214, 68, 147, 79, 146,
        215, 220, 221, 69, 11, 1, 152, 78, 10, 153, 214, 68, 147, 79, 146, 215, 220, 221, 69, 11 },
    { 45, 37, 80, 101, 223, 208, 102, 168, 191, 150, 7, 195, 251, 173, 38, 39, 10, 47, 127, 26, 197, 21, 115,
        219, 100, 242, 245, 54, 205, 96, 70, 97, 107, 68, 59, 33, 228, 241, 130, 89, 61, 207, 58, 12, 193, 161,
        231, 134, 237, 169, 146, 179, 87, 166, 36, 125, 64, 143, 181, 185, 120, 217, 62, 184, 85, 252, 110, 221, 138,
        44, 8, 117, 53, 186, 15, 182, 206, 23, 41, 145, 196, 56, 86, 139, 1, 45, 37, 80, 101 },
    { 90, 148, 186, 30, 226, 62, 109, 73, 179, 174, 162, 61, 131, 232, 96, 140, 153, 127, 52, 51, 168, 99, 98,
        56, 172, 22, 8, 234, 212, 185, 240, 67, 237, 79, 114, 241, 25, 121, 245, 108, 19, 39, 20, 188, 223, 189,
        133, 41, 63, 55, 221, 9, 176, 64, 3, 238, 161, 211, 34, 59, 66, 183, 219, 200, 239, 251, 71, 152, 37,
        160, 137, 182, 129, 92, 85, 229, 165, 166, 72, 233, 58, 24, 35, 97, 214, 13, 197, 42, 209 },
    { 180, 106, 185, 253, 17, 59, 132, 230, 150, 28, 172, 44, 32, 3, 193, 190, 214, 26, 51, 77, 145, 55, 167,
        36, 233, 116, 96, 5, 94, 223, 103, 46, 85, 215, 174, 89, 244, 108, 38, 156, 160, 15, 226, 124, 169, 114,
        255, 100, 239, 235, 1, 180, 106, 185, 253, 17, 59, 132, 230, 150, 28, 172, 44, 32, 3, 193, 190, 214, 26,
        51, 77, 145, 55, 167, 36, 233, 116, 96, 5, 94, 223, 103, 46, 85, 215, 174, 89, 244, 108 },
    { 117, 181, 161, 107, 26, 102, 41, 252, 87, 89, 245, 173, 45, 53, 185, 231, 68, 197, 168, 145, 110, 166, 61,
        54, 38, 37, 186, 120, 134, 59, 21, 191, 196, 221, 36, 207, 205, 39, 80, 15, 217, 237, 33, 115, 150, 56,
        138, 125, 58, 96, 10, 101, 182, 62, 169, 228, 219, 7, 86, 44, 64, 12, 70, 47, 223, 206, 184, 146, 241,
        100, 195, 139, 8, 143, 193, 97, 127, 208, 23, 85, 179, 130, 242, 251, 1, 117, 181, 161, 107 },
    { 234, 238, 97, 254, 103, 184, 57, 227, 7, 172, 176, 58, 192, 40, 15, 175, 147, 21, 99, 55, 166, 122, 216,
        45, 106, 222, 107, 52, 133, 85, 123, 50, 195, 11, 32, 12, 140, 188, 182, 124, 158, 115, 49, 224, 36, 131,
        19, 37, 105, 253, 68, 151, 154, 252, 174, 121, 251, 2, 201, 193, 194, 225, 206, 109, 114, 219, 14, 69, 125,
        116, 157, 80, 30, 67, 59, 42, 198, 110, 81, 244, 173, 90, 212, 161, 214, 104, 23, 170, 246 },
    { 201, 159, 47, 91, 124, 33, 209, 149, 166, 244, 71, 117, 238, 194, 223, 31, 79, 115, 98, 167, 61, 216, 90,
        181, 190, 254, 206, 218, 213, 150, 224, 72, 54, 152, 106, 161, 177, 189, 184, 114, 171, 56, 18, 131, 38, 148,
        111, 107, 104, 46, 146, 227, 14, 138, 233, 135, 37, 210, 211, 26, 133, 170, 241, 141, 172, 125, 232, 78, 186,
        253, 136, 102, 164, 123, 100, 43, 88, 58, 157, 160, 120, 34, 151, 41, 215, 25, 195, 22, 128 },
    { 143, 70, 101, 217, 59, 168, 252, 130, 195, 44, 58, 39, 186, 231, 26, 23, 146, 219, 56, 36, 54, 45, 181,
        97, 223, 62, 33, 191, 110, 89, 251, 8, 12, 10, 15, 134, 197, 41, 179, 100, 86, 125, 205, 37, 185, 107,
        208, 184, 228, 150, 221, 61, 173, 117, 193, 47, 182, 237, 21, 145, 87, 242, 139, 64, 96, 80, 120, 68, 102,
        85, 241, 7, 138, 207, 38, 53, 161, 127, 206, 169, 115, 196, 166, 245, 1, 143, 70, 101, 217 },
    { 3, 5, 15, 17, 51, 85, 255, 28, 36, 108, 180, 193, 94, 226, 59, 77, 215, 100, 172, 233, 38, 106, 190,
        223, 124, 132, 145, 174, 239, 44, 116, 156, 185, 214, 103, 169, 230, 55, 89, 235, 32, 96, 160, 253, 26, 46,
        114, 150, 167, 244, 1, 3, 5, 15, 17, 51, 85, 255, 28, 36, 108, 180, 193, 94, 226, 59, 77, 215, 100,
        172, 233, 38, 106, 190, 223, 124, 132, 145, 174, 239, 44, 116, 156, 185, 214, 103, 169, 230, 55 },
    { 6, 20, 120, 13, 46, 228, 98, 81, 251, 32, 192, 186, 187, 189, 169, 209, 220, 242, 22, 116, 37, 222, 254,
        62, 132, 63, 130, 43, 250, 38, 212, 194, 182, 147, 77, 179, 141, 9, 54, 180, 159, 101, 67, 151, 85, 227,
        112, 61, 142, 3, 10, 60, 136, 23, 114, 49, 166, 243, 16, 96, 93, 211, 208, 218, 230, 110, 121, 11, 58,
        156, 111, 127, 31, 66, 145, 65, 155, 125, 19, 106, 97, 91, 199, 168, 215, 200, 138, 27, 90 },
    { 12, 80, 231, 208, 169, 191, 87, 195, 125, 38, 181, 47, 217, 197, 85, 219, 221, 245, 8, 96, 186, 107, 206,
        33, 145, 130, 86, 207, 45, 193, 101, 134, 102, 146, 150, 166, 251, 64, 39, 185, 127, 62, 21, 252, 100, 138,
        54, 117, 70, 15, 68, 23, 228, 196, 89, 139, 58, 37, 161, 223, 237, 168, 179, 7, 36, 173, 143, 10, 120,
        26, 184, 115, 110, 242, 44, 205, 53, 97, 182, 59, 41, 241, 56, 61, 1, 12, 80, 231, 208 },
    { 24, 93, 107, 129, 132, 252, 200, 18, 173, 3, 40, 231, 189, 158, 145, 25, 69, 54, 234, 5, 120, 52, 218,
        191, 174, 43, 207, 90, 35, 15, 136, 92, 115, 220, 239, 125, 76, 238, 101, 17, 133, 228, 149, 121, 44, 135,
        212, 47, 175, 51, 146, 49, 162, 139, 116, 148, 97, 113, 236, 85, 171, 83, 251, 128, 156, 161, 163, 147, 41,
        255, 224, 245, 16, 157, 185, 254, 248, 168, 123, 28, 61, 2, 48, 186, 214, 31, 21, 229, 141 },
    { 48, 105, 127, 248, 77, 241, 224, 247, 64, 156, 95, 182, 236, 170, 150, 162, 11, 205, 212, 94, 134, 133, 213,
        110, 239, 250, 45, 35, 30, 26, 218, 99, 130, 69, 108, 143, 40, 211, 206, 132, 229, 7, 144, 2, 96, 210,
        254, 237, 154, 255, 221, 243, 128, 37, 190, 113, 197, 73, 49, 89, 22, 135, 181, 188, 17, 23, 183, 220, 195,
        233, 90, 70, 60, 52, 169, 198, 25, 138, 216, 3, 80, 187, 129, 21, 215, 14, 61, 4, 192 },
    { 96, 185, 223, 59, 85, 150, 89, 44, 38, 193, 15, 26, 169, 145, 100, 36, 1, 96, 185, 223, 59, 85, 150,
        89, 44, 38, 193, 15, 26, 169, 145, 100, 36, 1, 96, 185, 223, 59, 85, 150, 89, 44, 38, 193, 15, 26,
        169, 145, 100, 36, 1, 96, 185, 223, 59, 85, 150, 89, 44, 38, 193, 15, 26, 169, 145, 100, 36, 1, 96,
        185, 223, 59, 85, 150, 89, 44, 38, 193, 15, 26, 169, 145, 100, 36, 1, 96, 185, 223, 59 },
    { 192, 222, 182, 151, 114, 110, 155, 27, 143, 160, 177, 237, 82, 75, 89, 88, 152, 70, 240, 103, 21, 123, 224,
        251, 116, 212, 101, 136, 218, 145, 200, 144, 8, 78, 190, 217, 204, 183, 87, 172, 216, 12, 105, 225, 59, 170,
        98, 242, 250, 180, 10, 211, 31, 168, 255, 83, 139, 135, 238, 15, 52, 158, 252, 14, 244, 64, 74, 153, 134,
        46, 209, 130, 9, 142, 96, 111, 91, 197, 57, 55, 195, 131, 201, 80, 214, 248, 41, 171, 162 },
    { 157, 95, 217, 133, 230, 130, 18, 2, 39, 190, 175, 23, 209, 25, 36, 4, 78, 97, 67, 46, 191, 50, 72,
        8, 156, 194, 134, 92, 99, 100, 144, 16, 37, 153, 17, 184, 198, 200, 61, 32, 74, 47, 34, 109, 145, 141,
        122, 64, 148, 94, 68, 218, 63, 7, 244, 128, 53, 188, 136, 169, 126, 14, 245, 29, 106, 101, 13, 79, 252,
        28, 247, 58, 212, 202, 26, 158, 229, 56, 243, 116, 181, 137, 52, 33, 215, 112, 251, 232, 119 },
    { 39, 97, 134, 184, 145, 7, 245, 58, 181, 15, 208, 21, 241, 166, 44, 45, 10, 107, 237, 85, 196, 195, 54,
        12, 185, 182, 102, 115, 130, 36, 8, 37, 47, 68, 169, 252, 56, 251, 205, 193, 120, 206, 168, 219, 89, 125,
        117, 80, 127, 59, 146, 110, 86, 173, 96, 161, 217, 23, 191, 100, 61, 64, 53, 101, 26, 33, 179, 221, 139,
        38, 70, 231, 62, 41, 150, 242, 207, 143, 186, 223, 197, 228, 87, 138, 1, 39, 97, 134, 184 },
    { 78, 153, 68, 79, 215, 221, 11, 152, 10, 214, 147, 146, 220, 69, 1, 78, 153, 68, 79, 215, 221, 11, 152,
        10, 214, 147, 146, 220, 69, 1, 78, 153, 68, 79, 215, 221, 11, 152, 10, 214, 147, 146, 220, 69, 1, 78,
        153, 68, 79, 215, 221, 11, 152, 10, 214, 147, 146, 220, 69, 1, 78, 153, 68, 79, 215, 221, 11, 152, 10,
        214, 147, 146, 220, 69, 1, 78, 153, 68, 79, 215, 221, 11, 152, 10, 214, 147, 146, 220, 69 },
    { 156, 94, 26, 132, 255, 89, 233, 3, 185, 226, 46, 145, 28, 235, 38, 5, 214, 59, 114, 174, 36, 32, 106,
        15, 103, 77, 150, 239, 108, 96, 190, 17, 169, 215, 167, 44, 180, 160, 223, 51, 230, 100, 244, 116, 193, 253,
        124, 85, 55, 172, 1, 156, 94, 26, 132, 255, 89, 233, 3, 185, 226, 46, 145, 28, 235, 38, 5, 214, 59,
        114, 174, 36, 32, 106, 15, 103, 77, 150, 239, 108, 96, 190, 17, 169, 215, 167, 44, 180, 160 },
    { 37, 101, 208, 168, 150, 195, 173, 39, 47, 26, 21, 219, 242, 54, 96, 97, 68, 33, 241, 89, 207, 12, 161,
        134, 169, 179, 166, 125, 143, 185, 217, 184, 252, 221, 44, 117, 186, 182, 23, 145, 56, 139, 45, 80, 223, 102,
        191, 7, 251, 38, 10, 127, 197, 115, 100, 245, 205, 70, 107, 59, 228, 130, 61, 58, 193, 231, 237, 146, 87,
        36, 64, 181, 120, 62, 85, 110, 138, 8, 53, 15, 206, 41, 196, 86, 1, 37, 101, 208, 168 },
    { 74, 137, 206, 82, 55, 138, 16, 212, 120, 124, 73, 87, 72, 29, 193, 211, 147, 228, 25, 244, 205, 140, 177,
        197, 230, 141, 251, 76, 40, 223, 204, 198, 56, 11, 180, 186, 113, 92, 252, 167, 176, 143, 111, 67, 169, 123,
        162, 207, 24, 190, 68, 66, 227, 242, 108, 157, 47, 52, 84, 150, 155, 142, 37, 202, 103, 41, 149, 69, 8,
        106, 60, 62, 170, 165, 36, 128, 238, 231, 199, 114, 130, 122, 232, 70, 214, 236, 115, 200, 243 },
    { 148, 30, 62, 73, 174, 61, 232, 140, 127, 51, 99, 56, 22, 234, 185, 67, 79, 241, 121, 108, 39, 188, 189,
        41, 55, 9, 64, 238, 211, 59, 183, 200, 251, 152, 160, 182, 92, 229, 166, 233, 24, 97, 13, 42, 150, 43,
        2, 53, 60, 124, 146, 65, 122, 205, 5, 254, 102, 198, 112, 44, 201, 111, 134, 158, 255, 242, 216, 78, 101,
        103, 82, 110, 18, 128, 193, 187, 118, 115, 141, 235, 45, 93, 113, 184, 215, 81, 207, 48, 194 },
    { 53, 120, 237, 228, 100, 251, 45, 186, 217, 169, 241, 242, 173, 37, 15, 62, 146, 130, 245, 38, 80, 182, 184,
        179, 89, 54, 39, 101, 206, 85, 87, 61, 205, 10, 223, 23, 252, 166, 207, 96, 47, 208, 41, 110, 36, 58,
        70, 127, 102, 145, 221, 125, 12, 97, 26, 168, 196, 138, 64, 193, 107, 197, 191, 56, 44, 143, 161, 68, 21,
        150, 86, 8, 181, 231, 59, 115, 7, 139, 117, 185, 134, 33, 219, 195, 1, 53, 120, 237, 228 },
    { 106, 253, 59, 230, 28, 44, 3, 190, 26, 77, 55, 36, 116, 5, 223, 46, 215, 89, 108, 156, 15, 124, 114,
        100, 235, 180, 185, 17, 132, 150, 172, 32, 193, 214, 51, 145, 167, 233, 96, 94, 103, 85, 174, 244, 38, 160,
        226, 169, 255, 239, 1, 106, 253, 59, 230, 28, 44, 3, 190, 26, 77, 55, 36, 116, 5, 223, 46, 215, 89,
        108, 156, 15, 124, 114, 100, 235, 180, 185, 17, 132, 150, 172, 32, 193, 214, 51, 145, 167, 233 },
    { 212, 211, 197, 198, 167, 207, 157, 202, 62, 114, 200, 139, 201, 95, 26, 154, 220, 61, 19, 160, 217, 158, 171,
        86, 32, 159, 127, 133, 229, 89, 216, 74, 120, 147, 230, 56, 176, 24, 47, 103, 170, 130, 243, 90, 185, 34,
        42, 196, 18, 116, 10, 91, 109, 241, 239, 2, 181, 187, 151, 145, 83, 131, 39, 137, 124, 228, 141, 11, 143,
        190, 52, 41, 165, 122, 38, 93, 175, 33, 75, 172, 64, 35, 254, 23, 215, 178, 173, 148, 240 },
    { 181, 107, 102, 252, 89, 173, 53, 231, 197, 145, 166, 54, 37, 120, 59, 191, 221, 207, 39, 15, 237, 115, 56,
        125, 96, 101, 62, 228, 7, 44, 12, 47, 206, 146, 100, 139, 143, 97, 208, 85, 130, 251, 117, 161, 26, 41,
        87, 245, 45, 185, 68, 168, 110, 61, 38, 186, 134, 21, 196, 36, 205, 80, 217, 33, 150, 138, 58, 10, 182,
        169, 219, 86, 64, 70, 223, 184, 241, 195, 8, 193, 127, 23, 179, 242, 1, 181, 107, 102, 252 },
    { 119, 177, 23, 123, 239, 8, 159, 225, 184, 255, 43, 64, 140, 91, 169, 171, 69, 58, 20, 226, 33, 49, 18,
        205, 160, 67, 21, 149, 144, 38, 105, 34, 168, 220, 244, 45, 111, 13, 41, 174, 243, 117, 95, 104, 85, 25,
        203, 143, 194, 103, 146, 200, 22, 12, 94, 31, 228, 14, 176, 96, 202, 248, 115, 112, 233, 39, 30, 147, 191,
        167, 27, 37, 240, 236, 145, 81, 216, 53, 211, 51, 252, 178, 142, 181, 214, 133, 179, 249, 4 },
    { 238, 254, 184, 227, 172, 58, 40, 175, 21, 55, 122, 45, 222, 52, 85, 50, 11, 12, 188, 124, 115, 224, 131,
        37, 253, 151, 252, 121, 2, 193, 225, 109, 219, 69, 116, 80, 67, 42, 110, 244, 90, 161, 104, 170, 100, 22,
        24, 101, 248, 230, 221, 27, 74, 231, 51, 229, 242, 4, 159, 223, 218, 171, 138, 232, 160, 134, 84, 220, 245,
        180, 95, 208, 73, 200, 44, 48, 202, 237, 209, 167, 54, 148, 211, 102, 215, 249, 8, 35, 163 },
    { 193, 223, 169, 150, 36, 38, 185, 26, 85, 100, 44, 96, 15, 59, 145, 89, 1, 193, 223, 169, 150, 36, 38,
        185, 26, 85, 100, 44, 96, 15, 59, 145, 89, 1, 193, 223, 169, 150, 36, 38, 185, 26, 85, 100, 44, 96,
        15, 59, 145, 89, 1, 193, 223, 169, 150, 36, 38, 185, 26, 85, 100, 44, 96, 15, 59, 145, 89, 1, 193,
        223, 169, 150, 36, 38, 185, 26, 85, 100, 44, 96, 15, 59, 145, 89, 1, 193, 223, 169, 150 },
    { 159, 91, 33, 149, 244, 117, 194, 31, 115, 167, 216, 181, 254, 218, 150, 72, 152, 161, 189, 114, 56, 131, 148,
        107, 46, 227, 138, 135, 210, 26, 170, 141, 125, 78, 253, 102, 123, 43, 58, 160, 34, 41, 25, 22, 96, 30,
        236, 252, 249, 32, 10, 175, 84, 87, 235, 6, 101, 199, 198, 89, 2, 35, 182, 66, 55, 245, 234, 153, 62,
        230, 83, 173, 119, 225, 169, 49, 144, 45, 95, 103, 228, 112, 27, 53, 214, 92, 219, 9, 19 },
    { 35, 113, 21, 165, 235, 12, 137, 118, 252, 239, 128, 80, 34, 82, 100, 176, 78, 231, 133, 255, 138, 19, 111,
        208, 114, 112, 54, 212, 254, 169, 98, 122, 117, 153, 124, 191, 162, 2, 70, 226, 42, 87, 203, 24, 15, 236,
        229, 195, 29, 160, 68, 164, 200, 125, 156, 211, 23, 227, 9, 38, 222, 189, 228, 224, 108, 181, 225, 79, 196,
        244, 234, 47, 248, 99, 89, 4, 140, 217, 84, 174, 139, 48, 30, 197, 215, 155, 58, 93, 136 },
    { 70, 217, 168, 130, 44, 39, 231, 23, 219, 36, 45, 97, 62, 191, 89, 8, 10, 134, 41, 100, 125, 37, 107,
        184, 150, 61, 117, 47, 237, 145, 242, 64, 80, 68, 85, 7, 207, 53, 127, 169, 196, 245, 143, 101, 59, 252,
        195, 58, 186, 26, 146, 56, 54, 181, 223, 33, 110, 251, 12, 15, 197, 179, 86, 205, 185, 208, 228, 221, 173,
        193, 182, 21, 87, 139, 96, 120, 102, 241, 138, 38, 161, 206, 115, 166, 1, 70, 217, 168, 130 },
    { 140, 67, 41, 200, 233, 53, 254, 158, 110, 235, 48, 120, 204, 227, 36, 90, 153, 237, 63, 239, 58, 105, 104,
        228, 167, 142, 70, 175, 154, 100, 250, 148, 127, 79, 55, 251, 24, 60, 102, 255, 18, 45, 194, 248, 145, 249,
        29, 186, 52, 114, 221, 71, 35, 217, 77, 50, 125, 74, 177, 169, 149, 243, 12, 30, 51, 241, 9, 152, 97,
        124, 198, 242, 128, 93, 26, 57, 224, 173, 159, 226, 168, 25, 176, 37, 214, 218, 196, 247, 6 },
    { 5, 17, 85, 28, 108, 193, 226, 77, 100, 233, 106, 223, 132, 174, 44, 156, 214, 169, 55, 235, 96, 253, 46,
        150, 244, 3, 15, 51, 255, 36, 180, 94, 59, 215, 172, 38, 190, 124, 145, 239, 116, 185, 103, 230, 89, 32,
        160, 26, 114, 167, 1, 5, 17, 85, 28, 108, 193, 226, 77, 100, 233, 106, 223, 132, 174, 44, 156, 214, 169,
        55, 235, 96, 253, 46, 150, 244, 3, 15, 51, 255, 36, 180, 94, 59, 215, 172, 38, 190, 124 },
    { 10, 68, 146, 221, 1, 10, 68, 146, 221, 1, 10, 68, 146, 221, 1, 10, 68, 146, 221, 1, 10, 68, 146,
        221, 1, 10, 68, 146, 221, 1, 10, 68, 146, 221, 1, 10, 68, 146, 221, 1, 10, 68, 146, 221, 1, 10,
        68, 146, 221, 1, 10, 68, 146, 221, 1, 10, 68, 146, 221, 1, 10, 68, 146, 221, 1, 10, 68, 146, 221,
        1, 10, 68, 146, 221, 1, 10, 68, 146, 221, 1, 10, 68, 146, 221, 1, 10, 68, 146, 221 },
    { 20, 13, 228, 81, 32, 186, 189, 209, 242, 116, 222, 62, 63, 43, 38, 194, 147, 179, 9, 180, 101, 151, 227,
        61, 3, 60, 23, 49, 243, 96, 211, 218, 110, 11, 156, 127, 66, 65, 125, 106, 91, 168, 200, 27, 193, 175,
        164, 56, 71, 5, 68, 57, 83, 8, 160, 104, 115, 178, 29, 185, 129, 198, 195, 135, 190, 237, 229, 69, 45,
        94, 236, 241, 72, 201, 15, 204, 75, 245, 24, 253, 184, 149, 203, 39, 214, 158, 87, 88, 148 },
    { 40, 52, 115, 121, 116, 161, 248, 229, 138, 180, 202, 102, 75, 247, 96, 187, 79, 87, 176, 106, 182, 154, 14,
        173, 5, 136, 228, 162, 128, 185, 31, 63, 86, 152, 94, 197, 227, 122, 12, 253, 109, 110, 22, 74, 223, 84,
        200, 54, 35, 17, 146, 83, 16, 186, 103, 99, 195, 19, 194, 59, 246, 72, 143, 60, 46, 196, 203, 78, 127,
        132, 25, 207, 238, 175, 85, 224, 2, 80, 104, 230, 242, 232, 95, 237, 215, 9, 117, 137, 204 },
    { 80, 208, 191, 195, 38, 47, 197, 219, 245, 96, 107, 33, 130, 207, 193, 134, 146, 166, 64, 185, 62, 252, 138,
        117, 15, 23, 196, 139, 37, 223, 168, 7, 173, 10, 26, 115, 242, 205, 97, 59, 241, 61, 12, 231, 169, 87,
        125, 181, 217, 85, 221, 8, 186, 206, 145, 86, 45, 101, 102, 150, 251, 39, 127, 21, 100, 54, 70, 68, 228,
        89, 58, 161, 237, 179, 36, 143, 120, 184, 110, 44, 53, 182, 41, 56, 1, 80, 208, 191, 195 },
    { 160, 103, 145, 172, 180, 15, 46, 55, 44, 106, 226, 85, 167, 32, 185, 124, 215, 36, 3, 253, 169, 174, 233,
        193, 17, 114, 89, 116, 190, 59, 255, 244, 96, 214, 132, 100, 108, 5, 26, 230, 239, 38, 94, 51, 150, 235,
        156, 223, 77, 28, 1, 160, 103, 145, 172, 180, 15, 46, 55, 44, 106, 226, 85, 167, 32, 185, 124, 215, 36,
        3, 253, 169, 174, 233, 193, 17, 114, 89, 116, 190, 59, 255, 244, 96, 214, 132, 100, 108, 5 },
    { 93, 129, 252, 18, 3, 231, 158, 25, 54, 5, 52, 191, 43, 90, 15, 92, 220, 125, 238, 17, 228, 121, 135,
        47, 51, 49, 139, 148, 113, 85, 83, 128, 161, 147, 255, 245, 157, 254, 168, 28, 2, 186, 31, 229, 36, 6,
        211, 33, 50, 108, 10, 104, 99, 86, 180, 30, 184, 165, 250, 193, 34, 213, 242, 19, 94, 102, 98, 11, 53,
        226, 170, 166, 29, 95, 59, 227, 247, 39, 225, 77, 56, 4, 105, 62, 215, 72, 12, 187, 66 },
    { 186, 62, 179, 61, 96, 127, 168, 56, 8, 185, 237, 241, 245, 39, 223, 41, 221, 64, 161, 59, 219, 251, 37,
        182, 85, 166, 58, 97, 197, 150, 139, 53, 217, 146, 89, 205, 47, 102, 196, 44, 181, 134, 228, 242, 38, 101,
        23, 110, 125, 193, 68, 115, 195, 45, 15, 184, 87, 207, 70, 26, 191, 86, 117, 120, 169, 130, 54, 10, 208,
        145, 138, 143, 231, 33, 100, 173, 80, 206, 252, 36, 12, 107, 21, 7, 1, 186, 62, 179, 61 },
    { 105, 248, 241, 247, 156, 182, 170, 162, 205, 94, 133, 110, 250, 35, 26, 99, 69, 143, 211, 132, 7, 2, 210,
        237, 255, 243, 37, 113, 73, 89, 135, 188, 23, 220, 233, 70, 52, 198, 138, 3, 187, 21, 14, 4, 185, 199,
        227, 251, 74, 226, 146, 178, 19, 101, 46, 165, 207, 140, 104, 145, 9, 6, 107, 42, 28, 8, 111, 147, 219,
        235, 148, 217, 57, 121, 38, 202, 92, 87, 131, 5, 208, 63, 18, 12, 214, 84, 56, 16, 222 }
};

/**
 * @var variant_info
 * @brief Static table containing parameter sets for supported HQC KEM
 *        variants.
 *
 * Each entry defines the configuration parameters for a specific HQC
 * (Hamming Quasi-Cyclic) Key Encapsulation Mechanism variant identified
 * by its EVP_PKEY_HQC_KEM_* type.
 *
 * The fields specify algorithm-specific constants used for key and
 * ciphertext sizes, as well as cryptographic parameters controlling
 * performance and security levels.
 *
 * | Field                | Description |
 * |----------------------|-------------|
 * | type                 | HQC key type identifier (e.g., EVP_PKEY_HQC_KEM_128). |
 * | nid                  | nid of this hqc type |
 * | name                 | Human readable name of the key type. |
 * | ek/priv key len      | Encapsulation (public) key length in bytes. |
 * | dk/pub key len       | Decapsulation (private) key length in bytes. |
 * | seed length          | Length of the seed used for random generation. |
 * | security bytes       | Number of bytes representing the security level. |
 * | shared secret bytes  | Number of bytes in a shared secret for this key. |
 * | security category    | NIST security category (1–5). |
 * | secbits              | Effective security strength in bits. |
 * | N value              | Core polynomial modulus parameter. |
 * | N1 value             | Core polynomial modulus parameter. |
 * | N2 value             | Core polynomial modulus parameter. |
 * | N1N2 value           | ???. |
 * | N Mu value           | Derived constant for arithmetic operations. |
 * | G Value              | ??? |
 * | K Value              | ??? |
 * | Delta value          | ??? |
 * | FFT value            | ??? |
 * | M Value              | ??? |
 * | Reed Solomon Coefs   | Coefficients of the Reed Solomon Generator polynomial.|
 * | alpha ij powers      | Galois Field powers for Reed Solomon Decode. |
 * | Omega value          | Weight parameter used in error vector generation. |
 * | Omega-R value        | Weight parameter for redundancy or recovery data. |
 * | Omega-E value        | Weight parameter. |
 * | Salt Bytes           | Number of bytes to use in salting a message. |
 * | Rejection threshold  | Threshold used in probabilistic rejection sampling. |
 *
 * This structure is used internally by the HQC KEM implementation to
 * select and configure algorithm parameters based on the desired
 * security level.
 */
static const HQC_VARIANT_INFO variant_info[EVP_PKEY_HQC_KEM_MAX] = {
    {
        EVP_PKEY_HQC_KEM_128, /* type */
        EVP_PKEY_HQC_128, /* nid */
        "HQC-128", /* name */
        2241, /* ek/priv key len */
        2321, /* dk/pub key len */
        48, /* seed length */
        16, /* security bytes */
        32, /* shared secret bytes */
        1, /* security category */
        128, /* secbits */
        17669, /* N value */
        46, /* N1 value */
        384, /* N2 value */
        17664, /* N1N2 value */
        243079ULL, /* N Mu value */
        31, /* G value */
        16, /* K value */
        15, /* Delta value */
        4, /* FFT value */
        8, /* M value */
        hqc_1_rs_coefs, /* Reed Solomon Coefs */
        (uint16_t *)hqc_1_alpha_ij_pow, /* Alpha ij powers */
        45, /* Alpha ij power stride */
        66, /* Omega value */
        75, /* Omega-R value */
        75, /* Omega-E value */
        16, /* Salt bytes */
        16767881 /* Rejection threshold */
    },
    {
        EVP_PKEY_HQC_KEM_192, /* type */
        EVP_PKEY_HQC_192, /* nid */
        "HQC-192", /* name */
        4514, /* ek/priv key len */
        4602, /* dk/pub key len */
        48, /* seed length */
        24, /* security bytes */
        32, /* shared secret bytes */
        3, /* security category */
        192, /* secbits */
        35851, /* N value */
        56, /* N1 value */
        640, /* N2 value */
        35840, /* N1N2 value */
        119800ULL, /* N Mu value */
        33, /* G value */
        24, /* K value */
        16, /* Delta value */
        5, /* FFT value */
        8, /* M value */
        hqc_3_rs_coefs, /* Reed Solomon Coefs */
        (uint16_t *)hqc_3_alpha_ij_pow, /* Alpha ij powers */
        55, /* Alpha ij power stride */
        100, /* Omega value */
        114, /* Omega-R value */
        114, /* Omega-E value */
        16, /* Salt bytes */
        16742417 /* Rejection threshold */
    },
    {
        EVP_PKEY_HQC_KEM_256, /* type */
        EVP_PKEY_HQC_256, /* nid */
        "HQC-256", /* name */
        7237, /* ek/priv key len */
        7333, /* dk/pub key len */
        48, /* seed length */
        32, /* security bytes */
        32, /* shared secret bytes */
        5, /* security category */
        256, /* secbits */
        57637, /* N value */
        90, /* N1 value */
        640, /* N2 value */
        57600, /* N1N2 value */
        74517ULL, /* N Mu value */
        59, /* G value */
        32, /* K value */
        29, /* Delta value */
        5, /* FFT value */
        8, /* M value */
        hqc_5_rs_coefs, /* Reed Solomon Coefs */
        (uint16_t *)hqc_5_alpha_ij_pow, /* Alpha ij powers */
        89, /* Alpha ij power stride */
        131, /* Omega value */
        149, /* Omega-R value */
        149, /* Omega-E value */
        16, /* Salt bytes */
        16772367 /* Rejection threshold */
    }
};

/**
 * @struct hqc_kem_gen_ctx_st
 * @brief Context structure for HQC KEM key generation operations.
 *
 * This structure maintains the operational context and configuration
 * data used during the generation of HQC (Hamming Quasi-Cyclic) KEM
 * key pairs. It stores provider-specific information, algorithm
 * parameters, and references to hashing primitives.
 *
 * @var PROV_HQC_GEN_CTX::provctx
 *   Pointer to the provider context, enabling access to shared
 *   resources and configuration within the OpenSSL provider framework.
 *
 * @var PROV_HQC_GEN_CTX::propq
 *   Property query string used to resolve algorithm implementations
 *   (e.g., selecting specific digest variants or hardware providers).
 *
 * @var PROV_HQC_GEN_CTX::selection
 *   Bitmask indicating which portions of the key material (e.g., key
 *   pair, seed, or parameters) are selected for generation.
 *
 * @var PROV_HQC_GEN_CTX::evp_type
 *   Enumeration specifying the HQC key type or variant (e.g.,
 *   EVP_PKEY_HQC_KEM_128, EVP_PKEY_HQC_KEM_192, etc.).
 *
 * @var PROV_HQC_GEN_CTX::seed_len
 *   Length in bytes of the random seed used for deterministic key
 *   generation.
 *
 * @var PROV_HQC_GEN_CTX::seed
 *   Pointer to the seed buffer used in the pseudorandom generation
 *   process; may be user-supplied or internally generated.
 *
 * @var PROV_HQC_GEN_CTX::shake
 *   Pointer to the XOF (eXtendable Output Function) digest context
 *   (e.g., SHAKE128 or SHAKE256) used for randomness expansion.
 *
 * @var PROV_HQC_GEN_CTX::sha3
 *   Pointer to the SHA3 digest context (e.g., SHA3-256 or SHA3-512)
 *   used for auxiliary hashing operations during key generation.
 */
typedef struct hqc_kem_gen_ctx_st {
    PROV_CTX *provctx;
    char *propq;
    int selection;
    hqc_key_type evp_type;
    size_t seed_len;
    uint8_t *seed;
    EVP_MD *shake;
    EVP_MD *sha3;
} PROV_HQC_GEN_CTX;

/**
 * @brief Replaces or reallocates the public and private key buffers in
 *        an HQC key structure.
 *
 * This function frees any existing key buffers (`ek` and `dk`) in the
 * given HQC key structure and replaces them with new buffers provided
 * by the caller. If a new buffer pointer is `NULL`, the function
 * allocates a new zero-initialized buffer of the appropriate size using
 * OpenSSL's memory management functions.
 *
 * @param key
 *   Pointer to the HQC_KEY structure whose buffers are to be replaced.
 *
 * @param newpub
 *   Pointer to a new public key buffer. If `NULL`, a new buffer of size
 *   `key->info->ek_size` is allocated.
 *
 * @param newpriv
 *   Pointer to a new private key buffer. If `NULL`, a new buffer of size
 *   `key->info->dk_size` is allocated.
 *
 * @return
 *   Returns 1 on success (both buffers successfully replaced or
 *   allocated), or 0 if memory allocation fails for either buffer.
 *
 * @note
 *   - Existing buffers are freed before replacement.
 *   - When `newpriv` is `NULL`, failure to allocate the private key
 *     buffer will result in a return value of 0.
 *   - The function assumes `key->info` has been properly initialized
 *     with valid size values.
 */
static int hqc_kem_replace_keybufs(HQC_KEY *key, uint8_t *newpub, uint8_t *newpriv)
{
    OPENSSL_free(key->ek);
    OPENSSL_free(key->dk);

    if (newpub == NULL)
        key->ek = OPENSSL_zalloc(key->info->ek_size);
    else
        key->ek = newpub;
    if (newpriv == NULL)
        key->dk = OPENSSL_zalloc(key->info->dk_size);
    else
        key->dk = newpriv;

    return (key->ek == NULL || (key->dk == NULL && newpriv == NULL)) ? 0 : 1;
}

/**
 * @brief Frees all memory associated with an HQC key structure.
 *
 * This function safely releases the memory held by an HQC_KEY object,
 * including its public and private key buffers, and the key structure
 * itself. If the provided pointer is NULL, the function performs no
 * action.
 *
 * @param key
 *   Pointer to the HQC_KEY structure to be freed. May be NULL.
 *
 * @note
 *   - The function uses OpenSSL's memory management routines
 *     (`OPENSSL_free`) for deallocation.
 *   - Both the public key buffer (`ek`) and private key buffer (`dk`)
 *     are freed before the key structure itself.
 *   - The pointer passed to this function becomes invalid after the
 *     call and must not be used again.
 */
void hqc_kem_key_free(HQC_KEY *key)
{
    if (key == NULL)
        return;

    OPENSSL_free(key->ek);
    OPENSSL_free(key->dk);
    OPENSSL_free(key->seed);
    OPENSSL_free(key);
    return;
}

HQC_KEY *hqc_kem_new(int evp_type)
{
    HQC_KEY *new = OPENSSL_zalloc(sizeof(HQC_KEY));

    if (new == NULL)
        return NULL;

    new->info = &variant_info[evp_type];
    if (!hqc_kem_replace_keybufs(new, NULL, NULL)) {
        hqc_kem_key_free(new);
        new = NULL;
    }
    return new;
}

/**
 * @brief Allocates and initializes a new HQC key structure.
 *
 * This function creates a new HQC_KEY object, initializes it with the
 * specified HQC KEM variant information, and allocates memory for its
 * public and private key buffers. It uses OpenSSL’s memory management
 * routines for secure allocation.
 *
 * @param ctx
 *   Pointer to the provider context (PROV_CTX) used for managing
 *   provider-specific state. May be unused in this implementation but
 *   maintained for API consistency.
 *
 * @param propq
 *   Property query string used to control algorithm or provider
 *   selection. Stored in the HQC_KEY context if required by higher-level
 *   logic.
 *
 * @param evp_type
 *   Integer identifier corresponding to the HQC KEM variant (e.g.,
 *   EVP_PKEY_HQC_KEM_128, EVP_PKEY_HQC_KEM_192, etc.). Used to select
 *   the appropriate entry from the @c variant_info table.
 *
 * @return
 *   A pointer to a newly allocated HQC_KEY structure on success, or
 *   NULL if allocation or buffer initialization fails.
 *
 * @note
 *   - The function initializes both public and private key buffers to
 *     zeroed memory using @c hqc_kem_replace_keybufs().
 *   - On failure, any allocated memory is securely freed using
 *     @c hqc_kem_key_free().
 *   - The returned HQC_KEY pointer must later be freed with
 *     @c hqc_kem_key_free() to avoid memory leaks.
 */
static HQC_KEY *ossl_prov_hqc_kem_new(PROV_CTX *ctx, const char *propq, int evp_type)
{
    return hqc_kem_new(evp_type);
}

/**
 * @brief Checks whether a given HQC key contains the requested key components.
 *
 * This function determines if the provided HQC key structure (`HQC_KEY`)
 * includes the components specified by the `selection` bitmask. The selection
 * may request the presence of the public key, private key, or both. The
 * function returns true only if all requested components are present.
 *
 * @param vkey       Pointer to the HQC key structure to be checked.
 * @param selection  Bitmask indicating which key components to verify.
 *                   Possible values (can be combined using bitwise OR):
 *                   - OSSL_KEYMGMT_SELECT_PUBLIC_KEY
 *                   - OSSL_KEYMGMT_SELECT_PRIVATE_KEY
 *
 * @return 1 if the key contains all requested components, 0 otherwise.
 */
static int hqc_key_has(const void *vkey, int selection)
{
    int has = 0;
    int req = 0;
    const HQC_KEY *key = vkey;

    if (selection & OSSL_KEYMGMT_SELECT_PUBLIC_KEY) {
        req++;
        if (key->selection & OSSL_KEYMGMT_SELECT_PUBLIC_KEY)
            has++;
    }

    if (selection & OSSL_KEYMGMT_SELECT_PRIVATE_KEY) {
        req++;
        if (key->selection & OSSL_KEYMGMT_SELECT_PRIVATE_KEY)
            has++;
    }
    return (has == req);
}

/**
 * @brief Compares two HQC keys for equality based on the requested components.
 *
 * This function checks whether two HQC key structures (`HQC_KEY`) match for
 * the components specified by the `selection` bitmask. It first ensures that
 * both keys contain the requested components using ::hqc_key_has, then compares
 * their corresponding public or private key data for equality.
 *
 * @param vkey1      Pointer to the first HQC key structure.
 * @param vkey2      Pointer to the second HQC key structure.
 * @param selection  Bitmask specifying which key components to compare.
 *                   Possible values (can be combined using bitwise OR):
 *                   - OSSL_KEYMGMT_SELECT_PUBLIC_KEY
 *                   - OSSL_KEYMGMT_SELECT_PRIVATE_KEY
 *
 * @return 1 if all requested key components match, 0 otherwise.
 *
 * @note Both keys must contain all components specified by `selection`
 *       for the comparison to succeed.
 */
static int hqc_key_match(const void *vkey1, const void *vkey2, int selection)
{
    const HQC_KEY *key1 = vkey1;
    const HQC_KEY *key2 = vkey2;

    if (!hqc_key_has(key1, selection) || !hqc_key_has(key2, selection))
        return 0;

    if (selection & OSSL_KEYMGMT_SELECT_PUBLIC_KEY) {
        if (key1->info->ek_size != key2->info->ek_size)
            return 0;

        if (!memcmp(key1->ek, key2->ek, key1->info->ek_size))
            return 0;
    }

    if (selection & OSSL_KEYMGMT_SELECT_PRIVATE_KEY) {
        if (key1->info->dk_size != key2->info->dk_size)
            return 0;

        if (!memcmp(key1->dk, key2->dk, key1->info->dk_size))
            return 0;
    }

    return 1;
}

static int hqc_kem_validate(const void *vkey, int selection, int check_type)
{
    return 1; /* TODO implement me */
}

{
    -produce_param_decoder('hqc_kem_key_type_params',
        ([ 'OSSL_PKEY_PARAM_PRIV_KEY', 'privkey', 'octet_string' ],
            [ 'OSSL_PKEY_PARAM_PUB_KEY', 'pubkey', 'octet_string' ], ));
    -
}

/**
 * @brief Returns the set of import/export parameter types for HQC KEM
 *        keys based on the given selection mask.
 *
 * This function determines which parameter list should be used when
 * importing or exporting key material for an HQC (Hamming Quasi-Cyclic)
 * Key Encapsulation Mechanism key. If the selection includes the key
 * pair, it returns the predefined list of key type parameters;
 * otherwise, it returns NULL.
 *
 * @param selection
 *   Bitmask specifying the key components to be imported or exported.
 *   Typically includes values such as @c OSSL_KEYMGMT_SELECT_KEYPAIR.
 *
 * @return
 *   A pointer to a constant @c OSSL_PARAM array describing the
 *   parameters available for import/export, or NULL if the selection
 *   does not include key pair data.
 *
 * @note
 *   - The returned pointer refers to a static parameter list; it must
 *     not be modified or freed by the caller.
 *   - This function is used by the OpenSSL provider’s key management
 *     interface to advertise supported import/export capabilities.
 */
static const OSSL_PARAM *hqc_kem_imexport_types(int selection)
{
    if ((selection & OSSL_KEYMGMT_SELECT_KEYPAIR) != 0)
        return hqc_kem_key_type_params_list;
    return NULL;
}

/**
 * @brief Exports components of an HQC key as OSSL parameters.
 *
 * This function builds a parameter list representing the selected components
 * of an HQC key and passes them to a user-supplied callback. It supports
 * exporting the public key, private key, or both, based on the specified
 * `selection` bitmask. The generated parameters are provided through the
 * callback function `param_cb`.
 *
 * @param vkey       Pointer to the HQC key structure to export.
 * @param selection  Bitmask specifying which key components to export.
 *                   Possible values (can be combined using bitwise OR):
 *                   - OSSL_KEYMGMT_SELECT_PUBLIC_KEY
 *                   - OSSL_KEYMGMT_SELECT_PRIVATE_KEY
 * @param param_cb   Callback function that receives the built parameters.
 *                   The callback is expected to return 1 for success and
 *                   0 for failure.
 * @param cbarg      Pointer to user-defined data passed to the callback.
 *
 * @return 1 on success (parameters successfully exported and callback
 *         returned success), 0 on failure.
 *
 * @note The function validates that the provider is running and that the
 *       provided key includes all requested components via ::hqc_key_has.
 *       It also handles error cleanup for parameter builders and buffers.
 *
 * @warning This function assumes that `key->ek` and `key->dk` contain the
 *          encoded public and private key data respectively, with sizes
 *          defined in `key->info->ek_size` and `key->info->dk_size`.
 */
static int hqc_key_export(void *vkey, int selection, OSSL_CALLBACK *param_cb,
    void *cbarg)
{
    HQC_KEY *key = vkey;
    OSSL_PARAM_BLD *tmpl = NULL;
    OSSL_PARAM *params = NULL;
    int ret = 0;

    if (!ossl_prov_is_running() || key == NULL)
        return 0;

    if (!hqc_key_has(key, selection)) {
        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_KEY);
        return 0;
    }

    tmpl = OSSL_PARAM_BLD_new();

    if (tmpl == NULL)
        goto err;

    if (selection & OSSL_KEYMGMT_SELECT_PUBLIC_KEY) {
        if (!ossl_param_build_set_octet_string(tmpl, params, OSSL_PKEY_PARAM_PRIV_KEY,
                key->ek, key->info->ek_size))
            goto err;
    }

    if (selection & OSSL_KEYMGMT_SELECT_PUBLIC_KEY) {
        if (!ossl_param_build_set_octet_string(tmpl, params, OSSL_PKEY_PARAM_PUB_KEY,
                key->dk, key->info->dk_size))
            goto err;
    }

    params = OSSL_PARAM_BLD_to_param(tmpl);
    if (params == NULL)
        goto err;

    ret = param_cb(params, cbarg);
    OSSL_PARAM_free(params);

err:
    OSSL_PARAM_BLD_free(tmpl);
    return ret;
}

/**
 * @brief Initializes an HQC key structure from serialized key data.
 *
 * This function populates an existing HQC_KEY structure using key data
 * provided through an @c OSSL_PARAM array. It decodes and validates the
 * public (and optionally private) key components, ensuring they match
 * the expected sizes defined for the HQC variant. The decoded buffers
 * are then stored within the HQC_KEY object.
 *
 * @param key
 *   Pointer to the HQC_KEY structure to be initialized.
 *
 * @param params
 *   Array of @c OSSL_PARAM structures containing the encoded key data.
 *   Must include at least a public key entry, and optionally a private
 *   key entry if @p include_private is nonzero.
 *
 * @param include_private
 *   Nonzero if the private key should also be imported. When set, the
 *   function expects a valid private key entry in @p params.
 *
 * @return
 *   Returns 1 on success, or 0 on failure (e.g., invalid parameters,
 *   decoding errors, or size mismatches).
 *
 * @note
 *   - The function validates key lengths against @c key->info->ek_size
 *     and @c key->info->dk_size.
 *   - Allocated key buffers are replaced using
 *     @c hqc_kem_replace_keybufs().
 *   - On error, any partially allocated buffers are securely freed.
 *   - The caller must ensure that @p key is already allocated and that
 *     @p params contains valid HQC KEM key data.
 */
static int hqc_kem_key_fromdata(HQC_KEY *key,
    const OSSL_PARAM params[],
    int include_private)
{
    size_t pubkeylen, privkeylen;
    uint8_t *pubkey = NULL, *privkey = NULL;
    struct hqc_kem_key_type_params_st p;

    if (key == NULL || !hqc_kem_key_type_params_decoder(params, &p))
        goto err;

    key->selection = 0;
    if (p.pubkey == NULL)
        goto err;

    if (!OSSL_PARAM_get_octet_string(p.pubkey, (void **)&pubkey, 0,
            &pubkeylen))
        goto err;

    if (pubkeylen != key->info->ek_size)
        goto err;

    key->selection |= OSSL_KEYMGMT_SELECT_PUBLIC_KEY;

    if (include_private) {
        if (p.privkey == NULL)
            goto err;
        if (!OSSL_PARAM_get_octet_string(p.privkey, (void **)&privkey, 0,
                &privkeylen))
            goto err;
        if (privkeylen != key->info->dk_size)
            goto err;
        key->selection |= OSSL_KEYMGMT_SELECT_PRIVATE_KEY;
    }

    if (!hqc_kem_replace_keybufs(key, pubkey, privkey))
        goto err;

    return 1;

err:
    OPENSSL_free(pubkey);
    OPENSSL_free(privkey);
    return 0;
}

static int hqc_kem_import(void *vkey, int selection, const OSSL_PARAM params[])
{
    return hqc_kem_key_fromdata(vkey, params, selection & OSSL_KEYMGMT_SELECT_PRIVATE_KEY);
}

{
    -produce_param_decoder('hqc_kem_get_params',
        ([ 'OSSL_PKEY_PARAM_BITS', 'bits', 'int' ],
            [ 'OSSL_PKEY_PARAM_SECURITY_BITS', 'secbits', 'int' ],
            [ 'OSSL_PKEY_PARAM_MAX_SIZE', 'maxsize', 'int' ],
            [ 'OSSL_PKEY_PARAM_SECURITY_CATEGORY', 'seccat', 'int' ],
            [ 'OSSL_PKEY_PARAM_PRIV_KEY', 'privkey', 'octet_string' ],
            [ 'OSSL_PKEY_PARAM_PUB_KEY', 'pubkey', 'octet_string' ], ));
    -
}

/**
 * @brief Returns the list of gettable parameters for the HQC KEM
 *        provider implementation.
 *
 * This function provides OpenSSL with the static list of parameters
 * that can be queried from the HQC KEM (Hamming Quasi-Cyclic Key
 * Encapsulation Mechanism) algorithm implementation. It is typically
 * used by the provider framework to advertise supported metadata such
 * as algorithm names, security levels, or key sizes.
 *
 * @param provctx
 *   Pointer to the provider context. This parameter is unused but
 *   included for compatibility with the OpenSSL provider API.
 *
 * @return
 *   A pointer to a constant @c OSSL_PARAM array describing the
 *   gettable parameters supported by the HQC KEM implementation.
 *
 * @note
 *   - The returned pointer refers to a static, read-only parameter
 *     list and must not be modified or freed by the caller.
 *   - This function is part of the OpenSSL provider dispatch table for
 *     the HQC KEM key management interface.
 */
static const OSSL_PARAM *hqc_kem_gettable_params(void *provctx)
{
    return hqc_kem_get_params_list;
}

/**
 * @brief Exports HQC KEM key parameters into an OSSL_PARAM array.
 *
 * This function encodes data from an existing HQC_KEY structure into
 * an array of @c OSSL_PARAM objects. It allows OpenSSL's provider
 * framework to query the key’s public and private components, as well
 * as its security parameters (e.g., category and bit strength).
 *
 * @param vkey
 *   Pointer to the HQC_KEY structure containing the key material to be
 *   exported. Must not be NULL.
 *
 * @param params
 *   Array of @c OSSL_PARAM structures representing the output
 *   parameters. Each expected field (e.g., public key, private key,
 *   security category, bit strength) should be pre-initialized by the
 *   caller.
 *
 * @return
 *   Returns 1 on success, or 0 if decoding, encoding, or validation
 *   fails.
 *
 * @note
 *   - The function populates the following fields in @p params (if
 *     provided):
 *       - @c pubkey   → Public key bytes from @c key->ek
 *       - @c privkey  → Private key bytes from @c key->dk
 *       - @c seccat   → Security category (e.g., NIST level 1–5)
 *       - @c bits     → Security strength in bits
 *       - @c maxsize  → Public key length in bytes
 *   - The function uses @c OSSL_PARAM_set_* functions to safely encode
 *     data into the output parameter array.
 *   - If any field fails to encode, the function returns 0 immediately.
 *   - The caller must ensure that @p params is large enough to hold all
 *     requested values.
 */
static int hqc_kem_get_params(void *vkey, OSSL_PARAM params[])
{
    HQC_KEY *key = vkey;
    struct hqc_kem_get_params_st p;

    if (key == NULL || !hqc_kem_get_params_decoder(params, &p))
        return 0;

    if (p.pubkey != NULL && key->ek != NULL) {
        if (!OSSL_PARAM_set_octet_string(p.pubkey, key->ek, key->info->ek_size))
            return 0;
    }
    if (p.privkey != NULL && key->dk != NULL) {
        if (!OSSL_PARAM_set_octet_string(p.privkey, key->dk, key->info->dk_size))
            return 0;
    }
    if (p.seccat != NULL) {
        if (!OSSL_PARAM_set_int(p.seccat, key->info->security_category))
            return 0;
    }
    if (p.bits != NULL) {
        if (!OSSL_PARAM_set_int(p.bits, key->info->secbits))
            return 0;
    }
    if (p.maxsize != NULL) {
        if (!OSSL_PARAM_set_int(p.maxsize, key->info->dk_size))
            return 0;
    }

    return 1;
}

{
    -produce_param_decoder('hqc_kem_gen_set_params',
        ([ 'OSSL_PKEY_PARAM_HQC_SEED', 'seed', 'octet_string' ],
            [ 'OSSL_PKEY_PARAM_PROPERTIES', 'propq', 'utf8_string' ], ));
    -
}

/**
 * @brief Applies user-specified parameters to an HQC KEM key generation
 *        context.
 *
 * This function updates the @c PROV_HQC_GEN_CTX structure with
 * configuration values provided through an @c OSSL_PARAM array. It
 * supports updating the property query string and the deterministic
 * seed used for HQC KEM key generation.
 *
 * @param vgctx
 *   Pointer to the HQC KEM key generation context
 *   (@c PROV_HQC_GEN_CTX). Must not be NULL.
 *
 * @param params
 *   Array of @c OSSL_PARAM structures containing the configuration
 *   parameters to set. Recognized parameters include:
 *   - @c propq : UTF-8 string specifying the property query.
 *   - @c seed  : Octet string providing the random seed value.
 *
 * @return
 *   Returns 1 on success, or 0 if any parameter validation or memory
 *   allocation fails.
 *
 * @details
 *   - If the @c propq parameter is provided, the existing property
 *     query string in @p gctx is freed and replaced with a copy of the
 *     new value.
 *   - If the @c seed parameter is provided, its contents are validated
 *     and copied into the context. The seed length must exactly match
 *     the expected value for the selected HQC variant.
 *   - The function validates parameter data types before use (e.g.,
 *     @c propq must be a UTF-8 string).
 *
 * @note
 *   - On failure, the function ensures no partial updates are applied
 *     to the context.
 *   - The @c gctx->seed field is allocated using @c OPENSSL_memdup()
 *     and must be freed appropriately by the caller or higher-level
 *     cleanup routines.
 *   - This function is typically called through the OpenSSL provider
 *     API during HQC key generation setup.
 */
static int hqc_kem_gen_set_params(void *vgctx, const OSSL_PARAM params[])
{
    PROV_HQC_GEN_CTX *gctx = vgctx;
    struct hqc_kem_gen_set_params_st p;
    uint8_t *seed_ptr = NULL;

    if (gctx == NULL || !hqc_kem_gen_set_params_decoder(params, &p))
        return 0;

    if (p.propq != NULL) {
        if (p.propq->data_type != OSSL_PARAM_UTF8_STRING)
            return 0;
        OPENSSL_free(gctx->propq);
        if ((gctx->propq = OPENSSL_strdup(p.propq->data)) == NULL)
            return 0;
    }

    if (p.seed != NULL) {
        if (!OSSL_PARAM_get_octet_string_ptr(p.seed, (const void **)&seed_ptr, &gctx->seed_len))
            return 0;

        /*
         * Make sure we have a minimal seed length
         */
        if (gctx->seed_len != variant_info[gctx->evp_type].seed_len) {
            ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_SEED_LENGTH);
            return 0;
        }
        gctx->seed = OPENSSL_memdup(seed_ptr, gctx->seed_len);
        if (gctx->seed == NULL)
            return 0;
    }

    return 1;
}

/**
 * @brief Frees all resources associated with an HQC KEM key generation
 *        context.
 *
 * This function securely releases all dynamically allocated memory and
 * cryptographic resources held by a @c PROV_HQC_GEN_CTX structure. It
 * is typically called at the end of a key generation operation or when
 * an error occurs during context initialization.
 *
 * @param gctx
 *   Pointer to the HQC KEM key generation context to free. If NULL, the
 *   function performs no action.
 *
 * @details
 *   - Frees the property query string (@c gctx->propq).
 *   - Frees the deterministic seed buffer (@c gctx->seed).
 *   - Releases the digest contexts used for SHAKE and SHA3 operations.
 *   - Frees the @c PROV_HQC_GEN_CTX structure itself.
 *
 * @note
 *   - All memory deallocation is performed using OpenSSL’s secure
 *     memory management routines.
 *   - After calling this function, the @p gctx pointer becomes invalid
 *     and must not be reused.
 *   - This cleanup function ensures proper resource release within the
 *     OpenSSL provider framework.
 */
static void hqc_kem_cleanup_gen_ctx(PROV_HQC_GEN_CTX *gctx)
{
    if (gctx == NULL)
        return;

    OPENSSL_free(gctx->propq);
    OPENSSL_free(gctx->seed);
    EVP_MD_free(gctx->shake);
    EVP_MD_free(gctx->sha3);
    OPENSSL_free(gctx);
}

/**
 * @brief Initializes a new HQC KEM key generation context.
 *
 * This function allocates, initializes, and configures a
 * @c PROV_HQC_GEN_CTX structure for HQC (Hamming Quasi-Cyclic) Key
 * Encapsulation Mechanism key generation. It sets up the internal
 * context fields, applies user-specified parameters, and fetches the
 * required digest algorithms.
 *
 * @param provctx
 *   Pointer to the provider context used by the OpenSSL provider
 *   framework. Provides access to the library context and configuration
 *   data.
 *
 * @param selection
 *   Bitmask indicating which key components should be generated (e.g.,
 *   public key, private key, or both).
 *
 * @param params
 *   Optional array of @c OSSL_PARAM structures used to configure
 *   context parameters such as seed or property query strings. May be
 *   NULL if no parameters are provided.
 *
 * @param evp_type
 *   Integer identifier for the HQC KEM variant (e.g.,
 *   @c EVP_PKEY_HQC_KEM_128). Used to associate the correct parameter
 *   set and seed length.
 *
 * @return
 *   A pointer to a fully initialized @c PROV_HQC_GEN_CTX on success, or
 *   NULL on failure.
 *
 * @details
 *   - Allocates and zero-initializes the @c PROV_HQC_GEN_CTX structure.
 *   - Populates key generation parameters via
 *     @c hqc_kem_gen_set_params().
 *   - Fetches the SHAKE256 and SHA3-512 digest implementations from the
 *     provider library context.
 *   - On error, the function performs full cleanup via
 *     @c hqc_kem_cleanup_gen_ctx() before returning NULL.
 *
 * @note
 *   - The caller is responsible for freeing the returned context using
 *     @c hqc_kem_cleanup_gen_ctx() after use.
 *   - If digest initialization fails, the entire context is discarded
 *     to avoid inconsistent state.
 */
static void *hqc_kem_gen_init(void *provctx, int selection,
    const OSSL_PARAM params[], int evp_type)
{
    PROV_HQC_GEN_CTX *gctx = NULL;

    gctx = OPENSSL_zalloc(sizeof(*gctx));
    if (gctx == NULL)
        goto err;

    gctx->selection = selection;
    gctx->evp_type = evp_type;
    gctx->provctx = provctx;
    if (!hqc_kem_gen_set_params(gctx, params))
        goto err;

    /*
     * HQC key generation relies on SHAKE256 and SHA3-512 internally, allocate ciphers
     * for each here
     */
    gctx->shake = EVP_MD_fetch(PROV_LIBCTX_OF(provctx), "SHAKE256", gctx->propq);
    if (gctx->shake == NULL)
        goto err;

    gctx->sha3 = EVP_MD_fetch(PROV_LIBCTX_OF(provctx), "SHA3-512", gctx->propq);
    if (gctx->sha3 == NULL)
        goto err;

    return gctx;
err:
    hqc_kem_cleanup_gen_ctx(gctx);
    return NULL;
}

/**
 * @brief Returns the list of settable parameters for HQC KEM key
 *        generation.
 *
 * This function provides OpenSSL with the static list of parameters
 * that can be configured when initializing or modifying an HQC KEM
 * (Hamming Quasi-Cyclic Key Encapsulation Mechanism) key generation
 * context. It is used by the provider framework to advertise supported
 * configuration options for key generation.
 *
 * @param vgctx
 *   Pointer to the HQC KEM key generation context. This parameter is
 *   unused but retained for compatibility with the provider API.
 *
 * @param provctx
 *   Pointer to the provider context. This parameter is also unused but
 *   required by the OpenSSL provider interface.
 *
 * @return
 *   A pointer to a constant @c OSSL_PARAM array describing the
 *   parameters that may be set for HQC KEM key generation.
 *
 * @note
 *   - The returned list is static and must not be modified or freed by
 *     the caller.
 *   - Typical settable parameters include items such as property query
 *     strings and deterministic seed values.
 *   - This function forms part of the OpenSSL provider’s key generation
 *     dispatch table for HQC KEM implementations.
 */
static const OSSL_PARAM *hqc_kem_gen_settable_params(ossl_unused void *vgctx,
    ossl_unused void *provctx)
{
    return hqc_kem_gen_set_params_list;
}

/**
 * @brief Performs modular reduction using Barrett reduction for HQC
 *        arithmetic operations.
 *
 * This function computes the value of @p x modulo @c info->n using
 * Barrett reduction, a fast method for modular reduction that avoids
 * expensive division operations. It is used internally within the HQC
 * (Hamming Quasi-Cyclic) cryptographic routines for efficient modular
 * arithmetic.
 *
 * @param x
 *   The input value to be reduced.
 *
 * @param info
 *   Pointer to an @c HQC_VARIANT_INFO structure containing variant-
 *   specific parameters:
 *   - @c n     : The modulus.
 *   - @c n_mu  : The precomputed Barrett constant
 *                (⌊2³² / n⌋ or a scaled equivalent).
 *
 * @return
 *   The reduced value @c r such that @c 0 ≤ r < info->n.
 *
 * @details
 *   - Computes an approximate quotient @c q = ⌊(x * n_mu) / 2³²⌋.
 *   - Calculates the provisional remainder @c r = x − q × n.
 *   - Conditionally subtracts @c n if @c r ≥ n to ensure the result is
 *     within the correct range.
 *   - Uses bitwise operations instead of branching for constant-time
 *     behavior.
 *
 * @note
 *   - The computation is designed to be constant-time, avoiding
 *     conditional branches that could leak timing information.
 *   - The correctness of the reduction depends on the accuracy of the
 *     precomputed @c n_mu parameter for the given HQC variant.
 *   - This function is typically used in finite-field or polynomial
 *     arithmetic within HQC encryption and key encapsulation routines.
 */
static uint32_t barrett_reduce(uint32_t x, const HQC_VARIANT_INFO *info)
{
    uint64_t q = ((uint64_t)x * info->n_mu) >> 32;
    uint32_t r = x - (uint32_t)(q * info->n);
    uint32_t reduce_flag = (((r - info->n) >> 31) ^ 1);
    uint32_t mask = -reduce_flag;
    r -= mask & info->n;
    return r;
}

/**
 * @brief Samples a sparse binary vector deterministically using an
 *        extendable-output function (XOF).
 *
 * This function generates a binary vector with exactly
 * @c info->omega bits set, according to the HQC (Hamming Quasi-Cyclic)
 * cryptographic specification. The sampling is performed using a
 * pseudorandom byte stream derived from the provided XOF context.
 * Duplicate positions are rejected to ensure unique bit indices.
 *
 * @param md_ctx
 *   Pointer to the initialized @c EVP_MD_CTX representing the XOF
 *   context (e.g., SHAKE256). Used to generate pseudorandom bytes.
 *
 * @param vec
 *   Pointer to the output vector buffer where sampled bits will be set.
 *   Must be large enough to store @c VEC_SIZE(info->n, 64) 64-bit
 *   blocks.
 *
 * @param info
 *   Pointer to an @c HQC_VARIANT_INFO structure providing variant-
 *   specific parameters:
 *   - @c omega        : Number of bits to set in the vector.
 *   - @c omega_r      : Support vector size.
 *   - @c n            : Modulus size in bits.
 *   - @c rej_threshold: Rejection threshold for candidate values.
 *
 * @return
 *   Returns 1 on success, or 0 on failure (e.g., when random byte
 *   generation via @c xof_get_bytes() fails).
 *
 * @details
 *   - Random 24-bit integers are extracted from the XOF stream and
 *     reduced modulo @c n using @c barrett_reduce().
 *   - Duplicate indices are discarded to ensure uniqueness among
 *     selected bit positions.
 *   - For each valid index, the bit position and corresponding 64-bit
 *     word offset are recorded in lookup tables.
 *   - The final binary vector is assembled using bitwise OR operations
 *     across all selected indices.
 *   - The procedure avoids branching where possible to maintain
 *     constant-time behavior.
 *
 * @note
 *   - The caller must ensure that @c md_ctx has been properly seeded
 *     before calling this function.
 *   - The @c vec buffer is modified in place and should be zeroed
 *     before use if accumulation of bits is not intended.
 *   - This function is critical for HQC's error vector and random
 *     support generation steps, where cryptographic uniformity and
 *     reproducibility are required.
 */
static int hqc_sample_xof(EVP_MD_CTX *md_ctx, uint64_t *vec, const HQC_VARIANT_INFO *info)
{
    uint32_t support[info->omega_r];
    size_t random_bytes_size = 3 * info->omega;
    uint8_t rand_bytes[3 * info->omega_r];
    uint8_t inc;
    size_t i, j, k;
    uint32_t index_tab[info->omega_r];
    uint64_t bit_tab[info->omega_r];
    int32_t pos;
    uint64_t val;
    uint32_t tmp;
    int val1;
    uint64_t mask;

    memset(support, 0, info->omega_r * sizeof(uint32_t));
    memset(rand_bytes, 0, 3 * info->omega_r);
    memset(index_tab, 0, info->omega_r * sizeof(uint32_t));
    memset(bit_tab, 0, info->omega_r * sizeof(uint64_t));

    i = 0;
    j = random_bytes_size;
    while (i < info->omega) {
        do {
            if (j == random_bytes_size) {
                if (!xof_get_bytes(md_ctx, rand_bytes, random_bytes_size))
                    return 0;
                j = 0;
            }
            support[i] = ((uint32_t)rand_bytes[j++]) << 16;
            support[i] |= ((uint32_t)rand_bytes[j++]) << 8;
            support[i] |= rand_bytes[j++];
        } while (support[i] >= info->rej_threshold);

        support[i] = barrett_reduce(support[i], info);

        inc = 1;
        for (k = 0; k < i; k++) {
            if (support[k] == support[i])
                inc = 0;
        }
        i += inc;
    }

    for (i = 0; i < info->omega; i++) {
        index_tab[i] = support[i] >> 6;
        pos = support[i] & 0x3f;
        bit_tab[i] = ((uint64_t)1) << pos;
    }

    val = 0;
    for (i = 0; i < VEC_SIZE(info->n, 64); i++) {
        val = 0;
        for (j = 0; j < info->omega; j++) {
            tmp = i - index_tab[j];
            val1 = 1 ^ ((tmp | -tmp) >> 31);
            mask = -val1;
            val |= (bit_tab[j] & mask);
        }
        vec[i] |= val;
    }

    return 1;
}

/**
 * @brief Performs polynomial multiplication using the schoolbook method
 *        over GF(2).
 *
 * This function multiplies two binary polynomials represented as
 * 64-bit word arrays and stores the 128-bit result in the output
 * buffer. Each input operand is treated as a polynomial with binary
 * coefficients, and multiplication is performed modulo 2 (XOR-based
 * accumulation).
 *
 * @param r
 *   Pointer to the output buffer of size @c 2 * n 64-bit words. The
 *   buffer is zero-initialized at the start of the operation.
 *
 * @param a
 *   Pointer to the first input operand (multiplicand), represented as
 *   an array of @c n 64-bit words.
 *
 * @param b
 *   Pointer to the second input operand (multiplier), represented as
 *   an array of @c n 64-bit words.
 *
 * @param n
 *   Number of 64-bit words in each input operand.
 *
 * @details
 *   - Implements classic “schoolbook” polynomial multiplication in
 *     GF(2)[x].
 *   - Each bit of @p a is examined; if the bit is set, the polynomial
 *     @p b is XORed into the result @p r shifted by the bit’s position.
 *   - Bit-level shifts and XOR operations are used instead of
 *     arithmetic multiplication or addition.
 *   - Handles bit shifts across word boundaries, propagating high bits
 *     into the next word.
 *
 * @note
 *   - The result buffer @p r must be large enough to hold 2 × n 64-bit
 *     words.
 *   - Operates entirely in constant-time bitwise logic (no conditional
 *     branches on secret data).
 *   - This is a reference (non-optimized) implementation suitable for
 *     small operand sizes or as a fallback when Karatsuba or FFT-based
 *     multiplication is not beneficial.
 */
static void schoolbook_mul(uint64_t *r, const uint64_t *a, const uint64_t *b, size_t n)
{
    size_t i, j, base;
    int bit, sh, inv;
    uint64_t mask, ai;

    memset(r, 0, 2 * n * sizeof(uint64_t));
    for (i = 0; i < n; i++) {
        ai = a[i];
        for (bit = 0; bit < 64; bit++) {
            mask = -((ai >> bit) & 1ULL);
            base = i;
            sh = bit;
            inv = 64 - sh;
            if (sh == 0) {
                for (j = 0; j < n; j++) {
                    r[base + j] ^= b[j] & mask;
                }
            } else {
                for (j = 0; j < n; j++) {
                    r[base + j] ^= (b[j] << sh) & mask;
                    r[base + j + 1] ^= (b[j] >> inv) & mask;
                }
            }
        }
    }
}

/**
 * @brief Performs polynomial multiplication using the recursive
 *        Karatsuba algorithm over GF(2).
 *
 * This function computes the product of two binary polynomials
 * represented as arrays of 64-bit words, using the Karatsuba
 * divide-and-conquer algorithm for improved efficiency over the
 * classical schoolbook method. Multiplication and accumulation are
 * performed with XOR operations, as arithmetic is carried out in GF(2).
 *
 * @param r
 *   Pointer to the output buffer of size @c 2 * n 64-bit words, which
 *   will hold the resulting product. The buffer is cleared before
 *   accumulation.
 *
 * @param a
 *   Pointer to the first input operand (multiplicand), represented as
 *   an array of @c n 64-bit words.
 *
 * @param b
 *   Pointer to the second input operand (multiplier), represented as
 *   an array of @c n 64-bit words.
 *
 * @param n
 *   Number of 64-bit words in each input operand.
 *
 * @param tmp_buffer
 *   Pointer to a temporary buffer used for storing intermediate
 *   results and recursive workspace. The buffer must be large enough
 *   to accommodate several subproducts and temporary vectors.
 *
 * @details
 *   - For small operand sizes (@c n ≤ @c KARATSUBA_THRESHOLD), the
 *     function falls back to @c schoolbook_mul() for simplicity.
 *   - The operands are split into low and high halves:
 *     @f$a = a_0 + x^m a_1@f$, @f$b = b_0 + x^m b_1@f$.
 *   - The recursive Karatsuba formulation computes:
 *       - @c z0 = a0 * b0  (low product)
 *       - @c z2 = a1 * b1  (high product)
 *       - @c zmid = (a0 + a1) * (b0 + b1)
 *     and combines them via:
 *       @f$r = z0 + ((zmid ⊕ z0 ⊕ z2) << m) + (z2 << 2m)@f$.
 *   - XOR replaces addition to represent modular arithmetic in GF(2).
 *
 * @note
 *   - The algorithm runs in approximately O(n^1.585) time, offering
 *     better asymptotic performance than the quadratic schoolbook
 *     method for large n.
 *   - All arithmetic is constant-time with respect to data values,
 *     minimizing side-channel leakage.
 *   - Ensure @p tmp_buffer is sufficiently large; insufficient space
 *     may cause memory corruption.
 *   - Used internally for HQC finite-field and polynomial arithmetic
 *     operations where efficiency is critical.
 */
static void karatsuba_mul(uint64_t *r, const uint64_t *a, const uint64_t *b,
    size_t n, uint64_t *tmp_buffer)
{
    if (n <= KARATSUBA_THRESHOLD) {
        schoolbook_mul(r, a, b, n);
        return;
    }

    size_t m = n >> 1;
    size_t n0 = m;
    size_t n1 = n - m;

    /* take successive chunks of tmp_buffer for each intermediate result */
    uint64_t *z0 = tmp_buffer; /* low-half product, size 2*n words */
    uint64_t *z2 = z0 + 2 * n; /* high-half product, size 2*n words */
    uint64_t *zmid = z2 + 2 * n; /* middle product, size 2*n words */

    /* ta and tb hold the sums of low and high halves: */
    /* ta[i] = a0[i] XOR a1[i], tb[i] = b0[i] XOR b1[i] for i < n1 */
    uint64_t *ta = zmid + 2 * n;
    uint64_t *tb = ta + n;

    /* buffer for child recursions */
    uint64_t *child_buffer = tmp_buffer + 8 * n;

    /* 1) low * low */
    karatsuba_mul(z0, a, b, n0, child_buffer);

    /* 2) high * high */
    karatsuba_mul(z2, a + m, b + m, n1, child_buffer);

    /* 3) (a0+a1)*(b0+b1) */
    for (size_t i = 0; i < n1; i++) {
        uint64_t loa = (i < n0 ? a[i] : 0);
        uint64_t lob = (i < n0 ? b[i] : 0);
        ta[i] = loa ^ a[m + i];
        tb[i] = lob ^ b[m + i];
    }
    karatsuba_mul(zmid, ta, tb, n1, child_buffer);

    /* 4) assemble into r */
    memset(r, 0, 2 * n * sizeof(uint64_t));
    for (size_t i = 0; i < 2 * n0; i++)
        r[i] ^= z0[i];
    for (size_t i = 0; i < 2 * n1; i++)
        r[2 * m + i] ^= z2[i];
    for (size_t i = 0; i < 2 * n1; i++) {
        uint64_t z0i = (i < 2 * n0 ? z0[i] : 0);
        uint64_t z2i = (i < 2 * n1 ? z2[i] : 0);
        uint64_t mid = zmid[i] ^ z0i ^ z2i;
        r[m + i] ^= mid;
    }
}

/**
 * @brief Reduces a polynomial modulo (xⁿ + 1) for HQC arithmetic over GF(2).
 *
 * This function performs modular reduction of a doubled-length
 * polynomial represented as an array of 64-bit words. It reduces
 * the input polynomial @p a modulo (xⁿ + 1), where @p n is derived
 * from the HQC variant parameters, and stores the result in @p out.
 *
 * Reduction is done by XOR-folding the higher-degree part of the
 * polynomial back into the lower part, consistent with the ring
 * GF(2)[x]/(xⁿ + 1).
 *
 * @param out
 *   Pointer to the output buffer that will receive the reduced
 *   polynomial. Must have space for @c VEC_SIZE(info->n, 64) 64-bit
 *   words.
 *
 * @param a
 *   Pointer to the input polynomial to be reduced. The array must
 *   contain at least @c 2 * VEC_SIZE(info->n, 64) 64-bit words,
 *   representing the unreduced product.
 *
 * @param info
 *   Pointer to an @c HQC_VARIANT_INFO structure containing variant-
 *   specific parameters:
 *   - @c n : The modulus degree for the reduction (typically the HQC
 *            code length).
 *
 * @details
 *   - The function folds higher bits back into the lower half by
 *     shifting and XORing the upper words of @p a.
 *   - The shifting amount depends on @c info->n mod 64 to handle
 *     partial-word alignment.
 *   - The final word is masked using @c VEC_BITMASK() to ensure
 *     that bits above degree n−1 are cleared.
 *
 * @note
 *   - The operation is performed in-place on @p out, independent
 *     of @p a.
 *   - This reduction implements the standard HQC ring arithmetic
 *     requirement for polynomial operations modulo (xⁿ + 1).
 *   - All bitwise operations are constant-time and branch-free,
 *     maintaining side-channel resistance.
 */
static void reduce(uint64_t *out, const uint64_t *a, const HQC_VARIANT_INFO *info)
{
    for (size_t i = 0; i < VEC_SIZE(info->n, 64); i++) {
        uint64_t r = a[i + VEC_SIZE(info->n, 64) - 1] >> (info->n & 0x3F);
        uint64_t carry = a[i + VEC_SIZE(info->n, 64)] << (64 - (info->n & 0x3F));
        out[i] = a[i] ^ r ^ carry;
    }
    out[VEC_SIZE(info->n, 64) - 1] &= VEC_BITMASK(info->n, 64);
}

/**
 * @brief Multiplies two binary polynomials and reduces the result modulo
 *        (xⁿ + 1) for HQC arithmetic.
 *
 * This function computes the product of two polynomials over GF(2),
 * represented as arrays of 64-bit words, and performs modular reduction
 * to ensure the result fits within the polynomial ring
 * GF(2)[x]/(xⁿ + 1). It uses Karatsuba multiplication for efficiency
 * and the HQC-specific reduction function for modular folding.
 *
 * @param out
 *   Pointer to the output buffer where the reduced product is stored.
 *   Must have space for @c VEC_SIZE(info->n, 64) 64-bit words.
 *
 * @param a
 *   Pointer to the first input polynomial operand, represented as an
 *   array of @c VEC_SIZE(info->n, 64) 64-bit words.
 *
 * @param b
 *   Pointer to the second input polynomial operand, represented as an
 *   array of @c VEC_SIZE(info->n, 64) 64-bit words.
 *
 * @param info
 *   Pointer to an @c HQC_VARIANT_INFO structure that provides
 *   variant-specific parameters, including:
 *   - @c n : The modulus degree used in polynomial reduction.
 *
 * @details
 *   - The function first computes the unreduced polynomial product
 *     using @c karatsuba_mul(), which efficiently handles large-degree
 *     operands.
 *   - The intermediate result, stored in @c unreduced, contains up to
 *     2 × n bits.
 *   - The @c reduce() function then folds and masks the result modulo
 *     (xⁿ + 1) to ensure the final polynomial is within the desired
 *     ring.
 *   - Temporary buffers are stack-allocated for performance and
 *     security, avoiding heap allocations.
 *
 * @note
 *   - All operations are performed in GF(2) using XOR instead of
 *     arithmetic addition.
 *   - The function assumes that @c n and related parameters are valid
 *     for the HQC variant specified by @p info.
 *   - Used internally in HQC key generation and encapsulation routines
 *     where efficient and constant-time polynomial arithmetic is
 *     required.
 */
static void vec_mul(uint64_t *out, const uint64_t *a, const uint64_t *b, const HQC_VARIANT_INFO *info)
{
    uint64_t unreduced[2 * VEC_SIZE(info->n, 64)];
    uint64_t tmp_buffer[16 * VEC_SIZE(info->n, 64)];

    karatsuba_mul(unreduced, a, b, VEC_SIZE(info->n, 64), tmp_buffer);

    reduce(out, unreduced, info);
}

/**
 * @brief Performs bitwise vector addition (XOR) over GF(2).
 *
 * This function computes the bitwise XOR of two equal-length binary
 * vectors, storing the result in the output buffer. In the context of
 * HQC operations, this corresponds to polynomial addition modulo 2.
 *
 * @param o
 *   Pointer to the output buffer where the result is stored. Must have
 *   space for @p size 64-bit words.
 *
 * @param v1
 *   Pointer to the first input vector operand.
 *
 * @param v2
 *   Pointer to the second input vector operand.
 *
 * @param size
 *   The number of 64-bit words in each input vector.
 *
 * @details
 *   - Each output element is computed as:
 *     @code
 *     o[i] = v1[i] ^ v2[i];
 *     @endcode
 *   - This operation implements addition in the finite field GF(2),
 *     where XOR serves as the addition operator.
 *   - No carry or overflow occurs, as all operations are bitwise.
 *
 * @note
 *   - The input and output buffers may overlap safely.
 *   - The function runs in constant time with respect to the data
 *     values, suitable for use in cryptographic code.
 *   - Commonly used in HQC key generation, encryption, and error
 *     vector manipulation steps.
 */
static void vec_add(uint64_t *o, const uint64_t *v1, const uint64_t *v2, uint32_t size)
{
    for (uint32_t i = 0; i < size; ++i) {
        o[i] = v1[i] ^ v2[i];
    }
}

/**
 * @brief Extracts a specified number of bytes from an extendable-output
 *        function (XOF) context.
 *
 * This function retrieves pseudorandom bytes from an initialized XOF
 * digest context (e.g., SHAKE256) using the OpenSSL provider API. It
 * ensures that the requested number of bytes is produced even if the
 * total output size is not aligned to 64-bit boundaries.
 *
 * @param xof_ctx
 *   Pointer to the @c EVP_MD_CTX XOF context from which bytes are
 *   squeezed. Must be properly initialized with a SHAKE-based digest.
 *
 * @param output
 *   Pointer to the destination buffer that will receive the generated
 *   pseudorandom bytes.
 *
 * @param output_size
 *   Number of bytes to extract from the XOF stream.
 *
 * @return
 *   Returns 1 on success, or 0 if any call to
 *   @c EVP_DigestSqueeze() fails.
 *
 * @details
 *   - The function first extracts all full 64-bit blocks directly into
 *     the output buffer.
 *   - If @p output_size is not a multiple of 8, an additional 64-bit
 *     block is squeezed into a temporary buffer, and the remaining
 *     bytes are copied to complete the output.
 *   - This design ensures full coverage of the requested output size
 *     without alignment or padding issues.
 *
 * @note
 *   - The @p xof_ctx must be configured for a XOF-capable digest
 *     (e.g., SHAKE128 or SHAKE256).
 *   - This function maintains XOF state continuity — subsequent calls
 *     continue generating the next bytes in the pseudorandom sequence.
 *   - Commonly used in HQC for deterministic sampling and key material
 *     generation.
 */
static int xof_get_bytes(EVP_MD_CTX *xof_ctx, uint8_t *output, uint32_t output_size)
{
    const uint8_t bsize = sizeof(uint64_t);
    const uint8_t remainder = output_size % bsize;
    uint8_t tmp[sizeof(uint64_t)];

    if (!EVP_DigestSqueeze(xof_ctx, output, output_size - remainder))
        return 0;
    if (remainder != 0) {
        if (!EVP_DigestSqueeze(xof_ctx, tmp, bsize))
            return 0;
        output += output_size - remainder;
        for (uint8_t i = 0; i < remainder; i++) {
            output[i] = tmp[i];
        }
    }

    return 1;
}

static void hexdump(uint8_t *val, size_t len, char *msg)
{
    int idx = 0;

    fprintf(stderr, "%s\n", msg);
    for (idx = 0; idx < len; idx++) {
        fprintf(stderr, "%02x:", val[idx]);
        if (((idx + 1) % 16) == 0)
            fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
}

/**
 * @brief Generates a new HQC KEM public/private keypair.
 *
 * This function implements the full deterministic key generation
 * procedure for the HQC (Hamming Quasi-Cyclic) Key Encapsulation
 * Mechanism. It derives all necessary seeds, vectors, and
 * cryptographic components using extendable-output and hash-based
 * pseudorandom functions, producing both the public and private keys.
 *
 * @param vgctx
 *   Pointer to the HQC key generation context
 *   (@c PROV_HQC_GEN_CTX), which contains digest algorithms,
 *   property strings, and variant information.
 *
 * @param osslcb
 *   Optional callback function for progress or status reporting.
 *   Unused in this implementation.
 *
 * @param cbarg
 *   Optional callback argument passed to @p osslcb. Unused in this
 *   implementation.
 *
 * @return
 *   Returns a pointer to a fully populated @c HQC_KEY structure on
 *   success, or @c NULL on failure. On failure, all intermediate
 *   memory is securely freed.
 *
 * @details
 *   - Allocates a new HQC key structure via @c ossl_prov_hqc_kem_new().
 *   - Ensures deterministic operation via a fixed seed (either supplied
 *     by the user or generated randomly).
 *   - Uses SHAKE and SHA3 digests to derive sub-seeds:
 *       1. @c seed_kem  — base seed for keypair derivation.
 *       2. @c seed_pke  — seed for public key expansion.
 *       3. @c sigma     — random secret component.
 *       4. @c keypair_seed — concatenated decryption/encryption seeds.
 *   - Samples sparse vectors @c x and @c y using
 *     @c hqc_sample_xof(), computes the public polynomial @c h and
 *     derives the support vector @c s = x + y * h mod (xⁿ + 1).
 *   - Assembles the final keys:
 *       - Public key = (ek_seed || s)
 *       - Private key = (public key || dk_seed || sigma || seed_kem)
 *
 * @note
 *   - This function performs all operations in constant time where
 *     possible to maintain side-channel resistance.
 *   - Memory for sensitive data (e.g., seeds, sigma) is securely
 *     cleared before returning.
 *   - Requires properly initialized digest contexts for SHAKE256 and
 *     SHA3-512, as specified in @c PROV_HQC_GEN_CTX.
 *   - The caller is responsible for freeing the returned key with
 *     @c hqc_kem_key_free().
 */
static void *hqc_kem_gen(void *vgctx, OSSL_CALLBACK *osslcb, void *cbarg)
{
    PROV_HQC_GEN_CTX *gctx = vgctx;
    HQC_KEY *key;
    uint8_t keypair_seed[2 * SEED_BYTES];
    uint8_t seed_kem[SEED_BYTES];
    uint8_t sigma[variant_info[gctx->evp_type].security_bytes];
    uint8_t seed_pke[SEED_BYTES];
    uint8_t *dk_seed = keypair_seed;
    uint8_t *ek_seed = &keypair_seed[SEED_BYTES];
    uint8_t domain_separator = HQC_I_DOMAIN_SEP;
    uint8_t xof_separator = HQC_XOF_SEP;
    uint8_t domain = HQC_PRNG_DOMAIN_SEP;
    EVP_MD_CTX *md_ctx = NULL;
    unsigned int len;
    int ret = 0;
    uint64_t x[VEC_SIZE(variant_info[gctx->evp_type].n, 64)];
    uint64_t y[VEC_SIZE(variant_info[gctx->evp_type].n, 64)];
    uint64_t h[VEC_SIZE(variant_info[gctx->evp_type].n, 64)];
    uint64_t s[VEC_SIZE(variant_info[gctx->evp_type].n, 64)];

    key = ossl_prov_hqc_kem_new(gctx->provctx, gctx->propq, gctx->evp_type);
    if (key == NULL)
        goto err;

    memset(x, 0, VEC_SIZE(variant_info[gctx->evp_type].n, 64) * sizeof(uint64_t));
    memset(y, 0, VEC_SIZE(variant_info[gctx->evp_type].n, 64) * sizeof(uint64_t));
    memset(h, 0, VEC_SIZE(variant_info[gctx->evp_type].n, 64) * sizeof(uint64_t));
    memset(s, 0, VEC_SIZE(variant_info[gctx->evp_type].n, 64) * sizeof(uint64_t));

    /* we may need to generate a seed */
    if (gctx->seed == NULL) {
        gctx->seed = OPENSSL_malloc(VEC_SIZE(key->info->seed_len, 1));
        if (gctx->seed == NULL)
            return 0; /*seed gets freed when we free the ctx */
        if (!RAND_bytes_ex(PROV_LIBCTX_OF(gctx->provctx), gctx->seed,
                key->info->seed_len, 0))
            return 0;
    }

    key->seed = OPENSSL_memdup(gctx->seed, key->info->seed_len);
    if (key->seed == NULL)
        goto err;

    hexdump(key->seed, key->info->seed_len, "seed:");
    /*
     * Initalize our shake digest as a prng to generate our key seed from
     * the provided seed
     */
    md_ctx = EVP_MD_CTX_new();
    if (md_ctx == NULL)
        goto err;

    if (!EVP_DigestInit_ex2(md_ctx, gctx->shake, NULL))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, gctx->seed, key->info->seed_len))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, &domain, 1))
        goto err;
    if (!EVP_DigestSqueeze(md_ctx, (unsigned char *)seed_kem, SEED_BYTES))
        goto err;

    /*
     * Now use shake256 again to derive our seed_pke and sigma values
     */
    if (!EVP_DigestInit_ex2(md_ctx, gctx->shake, NULL))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, seed_kem, SEED_BYTES))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, &xof_separator, 1))
        goto err;
    if (!xof_get_bytes(md_ctx, seed_pke, SEED_BYTES))
        goto err;
    if (!xof_get_bytes(md_ctx, sigma, key->info->security_bytes))
        goto err;

    /*
     * Derive keypair seeds
     */
    if (!EVP_DigestInit_ex2(md_ctx, gctx->sha3, NULL))
        goto err;

    if (!EVP_DigestUpdate(md_ctx, seed_pke, SEED_BYTES))
        goto err;

    /*
     * Add a domain separator
     */
    if (!EVP_DigestUpdate(md_ctx, &domain_separator, 1))
        goto err;

    if (!EVP_DigestFinal_ex(md_ctx, keypair_seed, &len))
        goto err;

    /*
     * Compute decryption key
     */
    if (!EVP_DigestInit_ex2(md_ctx, gctx->shake, NULL))
        goto err;

    if (!EVP_DigestUpdate(md_ctx, dk_seed, SEED_BYTES))
        goto err;

    if (!EVP_DigestUpdate(md_ctx, &xof_separator, 1))
        goto err;

    /*
     * Sample the digest to get our x and y vectors
     */
    if (!hqc_sample_xof(md_ctx, y, key->info))
        goto err;
    if (!hqc_sample_xof(md_ctx, x, key->info))
        goto err;

    /*
     * Compute encryption key
     */
    if (!EVP_DigestInit_ex2(md_ctx, gctx->shake, NULL))
        goto err;

    if (!EVP_DigestUpdate(md_ctx, ek_seed, SEED_BYTES))
        goto err;

    if (!EVP_DigestUpdate(md_ctx, &xof_separator, 1))
        goto err;

    if (!EVP_DigestSqueeze(md_ctx, (unsigned char *)h, VEC_SIZE(key->info->n, 8)))
        goto err;

    h[VEC_SIZE(key->info->n, 64) - 1] &= VEC_BITMASK(key->info->n, 64);

    vec_mul(s, y, h, key->info);
    vec_add(s, x, s, VEC_SIZE(key->info->n, 64));

    /*
     * Place the encryption and decryption values into the key
     */
    memcpy(key->ek, ek_seed, SEED_BYTES);
    memcpy(key->ek + SEED_BYTES, s, VEC_SIZE(key->info->n, 8));
    memcpy(key->dk, key->ek, key->info->ek_size);
    memcpy(key->dk + key->info->ek_size, dk_seed, SEED_BYTES);
    memcpy(key->dk + key->info->ek_size + SEED_BYTES, sigma, key->info->security_bytes);
    memcpy(key->dk + key->info->ek_size + SEED_BYTES + key->info->security_bytes,
        seed_kem, SEED_BYTES);

    key->selection = OSSL_KEYMGMT_SELECT_PRIVATE_KEY | OSSL_KEYMGMT_SELECT_PUBLIC_KEY;
    ret = 1;
    hexdump(key->ek, key->info->ek_size, "key->ek:");
    hexdump(key->dk, key->info->dk_size, "key->dk:");

err:
    memset(keypair_seed, 0, 2 * SEED_BYTES);
    memset(seed_kem, 0, sizeof(seed_kem));
    memset(sigma, 0, sizeof(sigma));
    EVP_MD_CTX_free(md_ctx);
    if (ret == 0)
        hqc_kem_key_free(key);
    return ret == 1 ? key : NULL;
}

#ifndef FIPS_MODULE
/**
 * @brief Loads and reconstructs an HQC key from a serialized reference.
 *
 * This function takes ownership of a reference to an existing HQC key,
 * reconstitutes the key material using the HQC KEM generator context,
 * and returns a newly allocated HQC_KEY object. The reference is cleared
 * (set to NULL) to indicate transfer of ownership.
 *
 * The function verifies the running state of the provider and ensures
 * that the provided reference size matches the expected size of an HQC
 * key pointer. It then initializes a key generation context based on
 * the key type, duplicates the seed from the reference, regenerates the
 * key, and cleans up all intermediate resources.
 *
 * @param reference
 *     Pointer to a variable containing a reference to an HQC_KEY object.
 *     Ownership of this reference is transferred to the function, and
 *     the caller’s pointer will be set to NULL on success or failure.
 * @param reference_sz
 *     Size of the reference pointer (must match sizeof(HQC_KEY *)).
 *
 * @return
 *     A pointer to a newly allocated HQC_KEY structure on success,
 *     or NULL if an error occurs (e.g., invalid reference, context
 *     creation failure, or memory allocation failure).
 *
 * @note
 *     The caller is responsible for freeing the returned HQC_KEY
 *     using `hqc_kem_key_free()` when it is no longer needed.
 *
 * @internal
 * This function is used internally by the HQC provider to restore
 * serialized key material into a usable in-memory HQC_KEY object.
 */
static void *hqc_load(const void *reference, size_t reference_sz)
{
    HQC_KEY *key = NULL;
    PROV_HQC_GEN_CTX *ctx;
    const HQC_KEY *ref;

    if (!ossl_prov_is_running() || reference_sz != sizeof(key))
        goto err;

    ref = *(HQC_KEY **)reference;

    if (ref->selection != OSSL_KEYMGMT_SELECT_PUBLIC_KEY) {
        ctx = hqc_kem_gen_init(NULL, OSSL_KEYMGMT_SELECT_KEYPAIR, NULL, ref->info->type);
        if (ctx == NULL)
            goto err;

        /*
         * override the seed
         */
        ctx->seed = OPENSSL_memdup(ref->seed, ref->info->seed_len);

        /*
         * reconstitute the key
         */
        key = hqc_kem_gen(ctx, NULL, NULL);

        hqc_kem_cleanup_gen_ctx(ctx);
    } else {
        key = hqc_kem_new(ref->info->type);
        if (key != NULL) {
            memcpy(key->ek, ref->ek, key->info->ek_size);
            key->selection = ref->selection;
        }
    }
    return key;
err:
    hqc_kem_key_free(key);
    hqc_kem_cleanup_gen_ctx(ctx);
    return NULL;
}
#endif

/**
 * @brief Cleans up and frees an HQC KEM key generation context.
 *
 * This function releases all resources associated with a
 * @c PROV_HQC_GEN_CTX structure, including allocated memory and
 * digest contexts. It serves as the cleanup routine for the HQC KEM
 * key generation interface in the OpenSSL provider framework.
 *
 * @param vgctx
 *   Pointer to the HQC key generation context to be freed. May be NULL.
 *
 * @details
 *   - Delegates cleanup to @c hqc_kem_cleanup_gen_ctx(), which handles
 *     deallocation of all internal buffers, seed memory, and digest
 *     contexts.
 *   - Ensures consistent cleanup behavior regardless of partial or
 *     failed initialization states.
 *
 * @note
 *   - After this function is called, the context pointer becomes invalid
 *     and must not be reused.
 *   - This function is typically registered in the OpenSSL provider’s
 *     key generation dispatch table for HQC KEM operations.
 */
static void hqc_kem_gen_cleanup(void *vgctx)
{
    PROV_HQC_GEN_CTX *gctx = vgctx;
    hqc_kem_cleanup_gen_ctx(gctx);
}

/**
 * @brief Creates a duplicate of an HQC key with the selected components.
 *
 * This function allocates and initializes a new HQC key structure as a
 * duplicate of the provided key. It copies the requested components
 * (public key, private key, or both) from the source key into the new one.
 * The duplicated key retains the same type information as the original.
 *
 * @param vkey       Pointer to the HQC key structure to duplicate.
 * @param selection  Bitmask specifying which key components to copy.
 *                   Possible values (can be combined using bitwise OR):
 *                   - OSSL_KEYMGMT_SELECT_PUBLIC_KEY
 *                   - OSSL_KEYMGMT_SELECT_PRIVATE_KEY
 *
 * @return A pointer to the newly allocated HQC key structure on success,
 *         or NULL if duplication fails or if the source key does not
 *         contain the requested components.
 *
 * @note The function verifies that the source key contains the requested
 *       components using ::hqc_key_has before attempting duplication.
 *
 * @warning The returned key must be freed by the caller using the
 *          appropriate key free function (e.g., ::hqc_key_free) to avoid
 *          memory leaks.
 */
static void *hqc_kem_dup(const void *vkey, int selection)
{
    const HQC_KEY *key = vkey;
    HQC_KEY *dup;

    if (!hqc_key_has(key, selection))
        return NULL;

    dup = ossl_prov_hqc_kem_new(NULL, NULL, key->info->type);
    if (dup == NULL)
        return NULL;

    memcpy(dup->ek, key->ek, key->info->ek_size);
    memcpy(dup->dk, key->dk, key->info->dk_size);
    dup->selection = selection;

    return dup;
}

#ifndef FIPS_MODULE
#define DISPATCH_LOAD_FN \
    { OSSL_FUNC_KEYMGMT_LOAD, (OSSL_FUNC)hqc_load },
#else
#define DISPATCH_LOAD_FN /* Non-FIPS only */
#endif

#define DECLARE_VARIANT(bits)                                                              \
    static OSSL_FUNC_keymgmt_new_fn hqc_kem_##bits##_new;                                  \
    static OSSL_FUNC_keymgmt_gen_init_fn hqc_kem_##bits##_gen_init;                        \
    static void *hqc_kem_##bits##_new(void *provctx)                                       \
    {                                                                                      \
        return ossl_prov_hqc_kem_new(provctx, NULL, EVP_PKEY_HQC_KEM_##bits);              \
    }                                                                                      \
    static void *hqc_kem_##bits##_gen_init(void *provctx, int selection,                   \
        const OSSL_PARAM params[])                                                         \
    {                                                                                      \
        return hqc_kem_gen_init(provctx, selection, params,                                \
            EVP_PKEY_HQC_KEM_##bits);                                                      \
    }                                                                                      \
    const OSSL_DISPATCH ossl_hqc_##bits##_keymgmt_functions[] = {                          \
        { OSSL_FUNC_KEYMGMT_NEW, (OSSL_FUNC)hqc_kem_##bits##_new },                        \
        { OSSL_FUNC_KEYMGMT_FREE, (OSSL_FUNC)hqc_kem_key_free },                           \
        { OSSL_FUNC_KEYMGMT_GET_PARAMS, (OSSL_FUNC)hqc_kem_get_params },                   \
        { OSSL_FUNC_KEYMGMT_GETTABLE_PARAMS, (OSSL_FUNC)hqc_kem_gettable_params },         \
        { OSSL_FUNC_KEYMGMT_HAS, (OSSL_FUNC)hqc_key_has },                                 \
        { OSSL_FUNC_KEYMGMT_MATCH, (OSSL_FUNC)hqc_key_match },                             \
        { OSSL_FUNC_KEYMGMT_VALIDATE, (OSSL_FUNC)hqc_kem_validate },                       \
        { OSSL_FUNC_KEYMGMT_GEN_INIT, (OSSL_FUNC)hqc_kem_##bits##_gen_init },              \
        { OSSL_FUNC_KEYMGMT_GEN_SET_PARAMS, (OSSL_FUNC)hqc_kem_gen_set_params },           \
        { OSSL_FUNC_KEYMGMT_GEN_SETTABLE_PARAMS, (OSSL_FUNC)hqc_kem_gen_settable_params }, \
        { OSSL_FUNC_KEYMGMT_GEN, (OSSL_FUNC)hqc_kem_gen },                                 \
        { OSSL_FUNC_KEYMGMT_GEN_CLEANUP, (OSSL_FUNC)hqc_kem_gen_cleanup },                 \
        { OSSL_FUNC_KEYMGMT_DUP, (OSSL_FUNC)hqc_kem_dup },                                 \
        DISPATCH_LOAD_FN { OSSL_FUNC_KEYMGMT_IMPORT, (OSSL_FUNC)hqc_kem_import },          \
        { OSSL_FUNC_KEYMGMT_IMPORT_TYPES, (OSSL_FUNC)hqc_kem_imexport_types },             \
        { OSSL_FUNC_KEYMGMT_EXPORT, (OSSL_FUNC)hqc_key_export },                           \
        { OSSL_FUNC_KEYMGMT_EXPORT_TYPES, (OSSL_FUNC)hqc_kem_imexport_types },             \
        OSSL_DISPATCH_END                                                                  \
    }

/*
 * Declare the algorithm dispatch tables for all our key size variants
 */
DECLARE_VARIANT(128);
DECLARE_VARIANT(192);
DECLARE_VARIANT(256);
