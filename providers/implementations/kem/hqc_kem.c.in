/*
 * Copyright 2025 The OpenSSL Project Authors. All Rights Reserved.
 *
 * Licensed under the Apache License 2.0 (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 */
{
    -use OpenSSL::paramnames qw(produce_param_decoder);
    -
}

#include <string.h>
#include <openssl/crypto.h>
#include <openssl/evp.h>
#include <openssl/core_dispatch.h>
#include <openssl/core_names.h>
#include <openssl/params.h>
#include <openssl/rand.h>
#include <openssl/err.h>
#include <openssl/proverr.h>
#include "crypto/hqc_kem.h"
#include "internal/cryptlib.h"
#include "prov/provider_ctx.h"
#include "prov/implementations.h"
#include "prov/securitycheck.h"
#include "prov/providercommon.h"

static OSSL_FUNC_kem_newctx_fn hqc_kem_newctx;
static OSSL_FUNC_kem_freectx_fn hqc_kem_freectx;
static OSSL_FUNC_kem_encapsulate_init_fn hqc_kem_encapsulate_init;
static OSSL_FUNC_kem_encapsulate_fn hqc_kem_encapsulate;
static OSSL_FUNC_kem_decapsulate_init_fn hqc_kem_decapsulate_init;
static OSSL_FUNC_kem_decapsulate_fn hqc_kem_decapsulate;
static OSSL_FUNC_kem_set_ctx_params_fn hqc_kem_set_ctx_params;
static OSSL_FUNC_kem_settable_ctx_params_fn hqc_kem_settable_ctx_params;

/**
 * @def HQC_PRNG_DOMAIN_SEP
 * @brief Domain separation constant for the HQC PRNG (Pseudo-Random
 *        Number Generator).
 *
 * Used to distinguish the PRNG context from other cryptographic
 * primitives in HQC operations, ensuring unique input domains for
 * hashing or seed expansion functions.
 */
#define HQC_PRNG_DOMAIN_SEP 0

/** @def HQC_H_FCT_DOMAIN
 *  @brief Domain separator for the H(·) function in HQC.
 */
#define HQC_H_FCT_DOMAIN 1

/** @def HQC_G_FCT_DOMAIN
 *  @brief Domain separator for the G(·) function in HQC.
 */
#define HQC_G_FCT_DOMAIN 0

/** @def HQC_XOF_DOMAIN
 *  @brief Domain separator for the XOF function in HQC.
 */
#define HQC_XOF_DOMAIN 1

/**
 * @def KARATSUBA_THRESHOLD
 * @brief Threshold for switching to the Karatsuba multiplication
 *        algorithm.
 *
 * When the operand size (in coefficients, words, or bits—depending on
 * context) exceeds this threshold, the Karatsuba multiplication method
 * is used instead of the standard (schoolbook) multiplication.
 *
 * This value balances performance and overhead: smaller sizes use
 * simpler algorithms to reduce setup cost, while larger sizes benefit
 * from Karatsuba’s reduced asymptotic complexity.
 */
#define KARATSUBA_THRESHOLD 16

typedef struct {
    HQC_KEY *key;
    EVP_MD *shake;
    EVP_MD *sha3_256;
    EVP_MD *sha3_512;
    void *provctx;
    int op;
} PROV_HQC_KEM_CTX;

static void *hqc_kem_newctx(void *provctx)
{
    PROV_HQC_KEM_CTX *ctx;

    if ((ctx = OPENSSL_malloc(sizeof(*ctx))) == NULL)
        return NULL;

    ctx->key = NULL;
    ctx->provctx = provctx;
    return ctx;
}

static void hqc_kem_freectx(void *vctx)
{
    PROV_HQC_KEM_CTX *ctx = vctx;

    EVP_MD_free(ctx->shake);
    EVP_MD_free(ctx->sha3_256);
    EVP_MD_free(ctx->sha3_512);
    OPENSSL_free(ctx);
}

static int hqc_kem_init(void *vctx, int op, void *key,
    const OSSL_PARAM params[])
{
    PROV_HQC_KEM_CTX *ctx = vctx;

    if (!ossl_prov_is_running())
        return 0;
    ctx->key = key;
    ctx->op = op;
    ctx->shake = EVP_MD_fetch(PROV_LIBCTX_OF(ctx->provctx), "SHAKE256", NULL);
    if (ctx->shake == NULL)
        goto err;

    ctx->sha3_256 = EVP_MD_fetch(PROV_LIBCTX_OF(ctx->provctx), "SHA3-256", NULL);
    if (ctx->sha3_256 == NULL)
        goto err;

    ctx->sha3_512 = EVP_MD_fetch(PROV_LIBCTX_OF(ctx->provctx), "SHA3-512", NULL);
    if (ctx->sha3_512 == NULL)
        goto err;

    return hqc_kem_set_ctx_params(vctx, params);
err:
    hqc_kem_freectx(ctx);
    return 0;
}

static int hqc_kem_encapsulate_init(void *vctx, void *vkey,
    const OSSL_PARAM params[])
{
    return hqc_kem_init(vctx, EVP_PKEY_OP_ENCAPSULATE, vkey, params);
}

static int hqc_kem_decapsulate_init(void *vctx, void *vkey,
    const OSSL_PARAM params[])
{
    return hqc_kem_init(vctx, EVP_PKEY_OP_DECAPSULATE, vkey, params);
}

{
    -produce_param_decoder('hqc_kem_set_ctx_params', );
    -
}

static int hqc_kem_set_ctx_params(void *vctx, const OSSL_PARAM params[])
{
    PROV_HQC_KEM_CTX *ctx = vctx;
    struct hqc_kem_set_ctx_params_st p;

    if (ctx == NULL || !hqc_kem_set_ctx_params_decoder(params, &p))
        return 0;

    return 1;
}

static const OSSL_PARAM *hqc_kem_settable_ctx_params(ossl_unused void *vctx,
    ossl_unused void *provctx)
{
    return hqc_kem_set_ctx_params_list;
}

static inline uint32_t compare_u32(const uint32_t v1, const uint32_t v2)
{
    return 1 ^ (((v1 - v2) | (v2 - v1)) >> 31);
}

static int vect_sample_fixed_weight2(EVP_MD_CTX *md_ctx, HQC_KEY *key, uint64_t *v, uint16_t weight)
{
    uint32_t support[key->info->omega_r];
    uint32_t rand_u32[key->info->omega_r];
    uint32_t index_tab[key->info->omega_r];
    uint64_t bit_tab[key->info->omega_r];

    memset(support, 0, key->info->omega_r * sizeof(uint32_t));
    memset(rand_u32, 0, key->info->omega_r * sizeof(uint32_t));
    memset(index_tab, 0, key->info->omega_r * sizeof(uint32_t));
    memset(bit_tab, 0, key->info->omega_r * sizeof(uint64_t));

    if (!EVP_DigestSqueeze(md_ctx, (unsigned char *)rand_u32, weight * 4))
        return 0;

    for (size_t i = 0; i < weight; ++i) {
        uint64_t buff = rand_u32[i];
        support[i] = i + ((buff * (key->info->n - i)) >> 32);
    }

    for (int32_t i = (weight - 1); i-- > 0;) {
        uint32_t found = 0;

        for (size_t j = i + 1; j < weight; ++j) {
            found |= compare_u32(support[j], support[i]);
        }

        uint32_t mask = -found;
        support[i] = (mask & i) ^ (~mask & support[i]);
    }

    for (size_t i = 0; i < weight; i++) {
        index_tab[i] = support[i] >> 6;
        int32_t pos = support[i] & 0x3f;
        bit_tab[i] = ((uint64_t)1) << pos;
    }

    uint64_t val = 0;
    for (uint32_t i = 0; i < VEC_SIZE(key->info->n, 64); i++) {
        val = 0;
        for (uint32_t j = 0; j < weight; j++) {
            uint32_t tmp = i - index_tab[j];
            int val1 = 1 ^ ((tmp | -tmp) >> 31);
            uint64_t mask = -val1;
            val |= (bit_tab[j] & mask);
        }
        v[i] |= val;
    }

    return 1;
}

/**
 * @brief Performs polynomial multiplication using the schoolbook method
 *        over GF(2).
 *
 * This function multiplies two binary polynomials represented as
 * 64-bit word arrays and stores the 128-bit result in the output
 * buffer. Each input operand is treated as a polynomial with binary
 * coefficients, and multiplication is performed modulo 2 (XOR-based
 * accumulation).
 *
 * @param r
 *   Pointer to the output buffer of size @c 2 * n 64-bit words. The
 *   buffer is zero-initialized at the start of the operation.
 *
 * @param a
 *   Pointer to the first input operand (multiplicand), represented as
 *   an array of @c n 64-bit words.
 *
 * @param b
 *   Pointer to the second input operand (multiplier), represented as
 *   an array of @c n 64-bit words.
 *
 * @param n
 *   Number of 64-bit words in each input operand.
 *
 * @details
 *   - Implements classic “schoolbook” polynomial multiplication in
 *     GF(2)[x].
 *   - Each bit of @p a is examined; if the bit is set, the polynomial
 *     @p b is XORed into the result @p r shifted by the bit’s position.
 *   - Bit-level shifts and XOR operations are used instead of
 *     arithmetic multiplication or addition.
 *   - Handles bit shifts across word boundaries, propagating high bits
 *     into the next word.
 *
 * @note
 *   - The result buffer @p r must be large enough to hold 2 × n 64-bit
 *     words.
 *   - Operates entirely in constant-time bitwise logic (no conditional
 *     branches on secret data).
 *   - This is a reference (non-optimized) implementation suitable for
 *     small operand sizes or as a fallback when Karatsuba or FFT-based
 *     multiplication is not beneficial.
 */
static void schoolbook_mul(uint64_t *r, const uint64_t *a, const uint64_t *b, size_t n)
{
    size_t i, j, base;
    int bit, sh, inv;
    uint64_t mask, ai;

    memset(r, 0, 2 * n * sizeof(uint64_t));
    for (i = 0; i < n; i++) {
        ai = a[i];
        for (bit = 0; bit < 64; bit++) {
            mask = -((ai >> bit) & 1ULL);
            base = i;
            sh = bit;
            inv = 64 - sh;
            if (sh == 0) {
                for (j = 0; j < n; j++) {
                    r[base + j] ^= b[j] & mask;
                }
            } else {
                for (j = 0; j < n; j++) {
                    r[base + j] ^= (b[j] << sh) & mask;
                    r[base + j + 1] ^= (b[j] >> inv) & mask;
                }
            }
        }
    }
}

/**
 * @brief Performs polynomial multiplication using the recursive
 *        Karatsuba algorithm over GF(2).
 *
 * This function computes the product of two binary polynomials
 * represented as arrays of 64-bit words, using the Karatsuba
 * divide-and-conquer algorithm for improved efficiency over the
 * classical schoolbook method. Multiplication and accumulation are
 * performed with XOR operations, as arithmetic is carried out in GF(2).
 *
 * @param r
 *   Pointer to the output buffer of size @c 2 * n 64-bit words, which
 *   will hold the resulting product. The buffer is cleared before
 *   accumulation.
 *
 * @param a
 *   Pointer to the first input operand (multiplicand), represented as
 *   an array of @c n 64-bit words.
 *
 * @param b
 *   Pointer to the second input operand (multiplier), represented as
 *   an array of @c n 64-bit words.
 *
 * @param n
 *   Number of 64-bit words in each input operand.
 *
 * @param tmp_buffer
 *   Pointer to a temporary buffer used for storing intermediate
 *   results and recursive workspace. The buffer must be large enough
 *   to accommodate several subproducts and temporary vectors.
 *
 * @details
 *   - For small operand sizes (@c n ≤ @c KARATSUBA_THRESHOLD), the
 *     function falls back to @c schoolbook_mul() for simplicity.
 *   - The operands are split into low and high halves:
 *     @f$a = a_0 + x^m a_1@f$, @f$b = b_0 + x^m b_1@f$.
 *   - The recursive Karatsuba formulation computes:
 *       - @c z0 = a0 * b0  (low product)
 *       - @c z2 = a1 * b1  (high product)
 *       - @c zmid = (a0 + a1) * (b0 + b1)
 *     and combines them via:
 *       @f$r = z0 + ((zmid ⊕ z0 ⊕ z2) << m) + (z2 << 2m)@f$.
 *   - XOR replaces addition to represent modular arithmetic in GF(2).
 *
 * @note
 *   - The algorithm runs in approximately O(n^1.585) time, offering
 *     better asymptotic performance than the quadratic schoolbook
 *     method for large n.
 *   - All arithmetic is constant-time with respect to data values,
 *     minimizing side-channel leakage.
 *   - Ensure @p tmp_buffer is sufficiently large; insufficient space
 *     may cause memory corruption.
 *   - Used internally for HQC finite-field and polynomial arithmetic
 *     operations where efficiency is critical.
 */
static void karatsuba_mul(uint64_t *r, const uint64_t *a, const uint64_t *b,
    size_t n, uint64_t *tmp_buffer)
{
    if (n <= KARATSUBA_THRESHOLD) {
        schoolbook_mul(r, a, b, n);
        return;
    }

    size_t m = n >> 1;
    size_t n0 = m;
    size_t n1 = n - m;

    /* take successive chunks of tmp_buffer for each intermediate result */
    uint64_t *z0 = tmp_buffer; /* low-half product, size 2*n words */
    uint64_t *z2 = z0 + 2 * n; /* high-half product, size 2*n words */
    uint64_t *zmid = z2 + 2 * n; /* middle product, size 2*n words */

    /* ta and tb hold the sums of low and high halves: */
    /* ta[i] = a0[i] XOR a1[i], tb[i] = b0[i] XOR b1[i] for i < n1 */
    uint64_t *ta = zmid + 2 * n;
    uint64_t *tb = ta + n;

    /* buffer for child recursions */
    uint64_t *child_buffer = tmp_buffer + 8 * n;

    /* 1) low * low */
    karatsuba_mul(z0, a, b, n0, child_buffer);

    /* 2) high * high */
    karatsuba_mul(z2, a + m, b + m, n1, child_buffer);

    /* 3) (a0+a1)*(b0+b1) */
    for (size_t i = 0; i < n1; i++) {
        uint64_t loa = (i < n0 ? a[i] : 0);
        uint64_t lob = (i < n0 ? b[i] : 0);
        ta[i] = loa ^ a[m + i];
        tb[i] = lob ^ b[m + i];
    }
    karatsuba_mul(zmid, ta, tb, n1, child_buffer);

    /* 4) assemble into r */
    memset(r, 0, 2 * n * sizeof(uint64_t));
    for (size_t i = 0; i < 2 * n0; i++)
        r[i] ^= z0[i];
    for (size_t i = 0; i < 2 * n1; i++)
        r[2 * m + i] ^= z2[i];
    for (size_t i = 0; i < 2 * n1; i++) {
        uint64_t z0i = (i < 2 * n0 ? z0[i] : 0);
        uint64_t z2i = (i < 2 * n1 ? z2[i] : 0);
        uint64_t mid = zmid[i] ^ z0i ^ z2i;
        r[m + i] ^= mid;
    }
}

static void reduce(uint64_t *out, const uint64_t *a, const HQC_VARIANT_INFO *info)
{
    for (size_t i = 0; i < VEC_SIZE(info->n, 64); i++) {
        uint64_t r = a[i + VEC_SIZE(info->n, 64) - 1] >> (info->n & 0x3F);
        uint64_t carry = a[i + VEC_SIZE(info->n, 64)] << (64 - (info->n & 0x3F));
        out[i] = a[i] ^ r ^ carry;
    }
    out[VEC_SIZE(info->n, 64) - 1] &= VEC_BITMASK(info->n, 64);
}

static void vect_mul(uint64_t *out, const uint64_t *a, const uint64_t *b, const HQC_KEY *key)
{
    uint64_t unreduced[2 * VEC_SIZE(key->info->n, 64)];
    uint64_t tmp_buffer[16 * VEC_SIZE(key->info->n, 64)];

    karatsuba_mul(unreduced, a, b, VEC_SIZE(key->info->n, 64), tmp_buffer);

    reduce(out, unreduced, key->info);
}

/**
 * @brief Adds two vectors
 *
 * @param[out] o Pointer to an array that is the result
 * @param[in] v1 Pointer to an array that is the first vector
 * @param[in] v2 Pointer to an array that is the second vector
 * @param[in] size Integer that is the size of the vectors
 */
void vect_add(uint64_t *o, const uint64_t *v1, const uint64_t *v2, uint32_t size)
{
    for (uint32_t i = 0; i < size; ++i) {
        o[i] = v1[i] ^ v2[i];
    }
}

static void gf_carryless_mul(uint8_t *c, uint8_t a, uint8_t b)
{
    uint16_t h = 0, l = 0, g, u[4];
    u[0] = 0;
    u[1] = b & ((1UL << 7) - 1UL);
    u[2] = u[1] << 1;
    u[3] = u[2] ^ u[1];

    g = 0;
    uint16_t tmp1 = a & 3;

    for (int i = 0; i < 4; i++) {
        uint32_t tmp2 = tmp1 - i;
        g ^= (u[i] & -(1 - ((tmp2 | -tmp2) >> 31)));
    }

    l = g;
    h = 0;

    for (uint8_t i = 2; i < 8; i += 2) {
        g = 0;
        uint16_t tmp3 = (a >> i) & 3;
        for (int j = 0; j < 4; ++j) {
            uint32_t tmp2 = tmp3 - j;
            g ^= (u[j] & -(1 - ((tmp2 | -tmp2) >> 31)));
        }

        l ^= g << i;
        h ^= g >> (8 - i);
    }

    uint16_t mask = (-((b >> 7) & 1));
    l ^= ((a << 7) & mask);
    h ^= ((a >> (1)) & mask);

    c[0] = l;
    c[1] = h;
}

static uint16_t gf_reduce(uint16_t x)
{
    uint64_t mod;
    const int reduction_steps = 2; // For deg(x) = 2 * (8 - 1) = 14, reduce twice to bring degree < 8
    const size_t gf_reduction_tap_count = 3; // Number of feedback positions
    static const uint8_t gf_reduction_taps[] = { 4, 3, 2 };

    for (int i = 0; i < reduction_steps; ++i) {
        mod = x >> 8; // Extract upper bits
        x &= (1 << 8) - 1; // Keep lower bits
        x ^= mod; // Pre-XOR with no shift

        uint16_t z1 = 0;
        for (size_t j = gf_reduction_tap_count; j; --j) {
            uint16_t z2 = gf_reduction_taps[j - 1];
            uint16_t dist = z2 - z1;
            mod <<= dist;
            x ^= mod;
            z1 = z2;
        }
    }

    return x;
}

static uint16_t gf_mul(uint16_t a, uint16_t b)
{
    uint8_t c[2] = { 0, 0 };
    uint16_t tmp;

    gf_carryless_mul(c, (uint8_t)a, (uint8_t)b);
    tmp = (uint16_t)(c[0] ^ (c[1] << 8));
    return gf_reduce(tmp);
}

typedef union {
    uint8_t u8[16]; /**< Byte-wise access (16 bytes) */
    uint32_t u32[4]; /**< Word-wise access (4 32-bit words) */
} rm_codeword_t;

/**
 * @def BIT0MASK(x)
 * @brief Broadcast the least significant bit of \p x to a 32-bit mask.
 *
 * @param x  An integer expression; only bit 0 is examined.
 * @return   A 32-bit value of all ones (if \p x&1 == 1) or all zeros (if \p x&1 == 0).
 */
#define BIT0MASK(x) (int32_t)(-((x) & 1))

static void encode(rm_codeword_t *word, int32_t message)
{
    int32_t first_word;

    first_word = BIT0MASK(message >> 7);

    first_word ^= BIT0MASK(message >> 0) & 0xaaaaaaaa;
    first_word ^= BIT0MASK(message >> 1) & 0xcccccccc;
    first_word ^= BIT0MASK(message >> 2) & 0xf0f0f0f0;
    first_word ^= BIT0MASK(message >> 3) & 0xff00ff00;
    first_word ^= BIT0MASK(message >> 4) & 0xffff0000;

    word->u32[0] = first_word;

    first_word ^= BIT0MASK(message >> 5);
    word->u32[1] = first_word;
    first_word ^= BIT0MASK(message >> 6);
    word->u32[3] = first_word;
    first_word ^= BIT0MASK(message >> 5);
    word->u32[2] = first_word;
    return;
}

static void code_encode(HQC_KEY *key, uint64_t *em, const uint64_t *m)
{
    uint64_t tmp[VEC_SIZE(key->info->n1, 8)];
    uint16_t tmp_g[key->info->g];
    uint8_t msg_bytes[key->info->k];
    uint8_t cdw_bytes[key->info->n1];
    size_t i, j, k;
    uint8_t gate_value = 0;
    uint8_t *msg_array;
    rm_codeword_t *code_array = (rm_codeword_t *)em;

    memset(tmp, 0, VEC_SIZE(key->info->n1, 8) * sizeof(uint64_t));
    memset(msg_bytes, 0, key->info->k);
    memset(cdw_bytes, 0, key->info->n1);
    memset(tmp_g, 0, key->info->g * sizeof(uint16_t));
    /*
     * Do a reed/solomon encoding of the message to the tmp variable
     */
    memcpy(msg_bytes, m, key->info->k);
    for (i = 0; i < key->info->k; ++i) {
        gate_value = msg_bytes[key->info->k - 1 - i] ^ cdw_bytes[key->info->n1 - key->info->k - 1];

        for (j = 0; j < key->info->g; ++j) {
            tmp_g[j] = gf_mul(gate_value, key->info->rs_coefs[j]);
        }

        for (k = key->info->n1 - key->info->k - 1; k; --k) {
            cdw_bytes[k] = cdw_bytes[k - 1] ^ tmp_g[k];
        }

        cdw_bytes[0] = tmp_g[0];
    }

    memcpy(cdw_bytes + key->info->n1 - key->info->k, msg_bytes, key->info->k);
    memcpy(tmp, cdw_bytes, key->info->n1);

    /*
     * Now reed-muller encode the tmp result to em
     */
    msg_array = (uint8_t *)tmp;
    for (size_t i = 0; i < VEC_SIZE(key->info->n1, 8); i++) {
        // fill entries i * VEC_SIZE(key->info->n2) to (i+1) * VEC_SIZE(key->info->n2, 128)
        int32_t pos = i * VEC_SIZE(key->info->n2, 128);
        // encode first word
        encode(&code_array[pos], msg_array[i]);
        // copy to other identical codewords
        for (size_t copy = 1; copy < VEC_SIZE(key->info->n2, 128); copy++) {
            memcpy(&code_array[pos + copy], &code_array[pos], sizeof(rm_codeword_t));
        }
    }
}

void vect_truncate(uint64_t *v, HQC_KEY *key)
{
    size_t orig_words = (key->info->n + 63) / 64;
    size_t new_full_words = key->info->n1n2 / 64;
    size_t remaining_bits = key->info->n1n2 % 64;

    // Mask the last word if there's a partial word
    if (remaining_bits > 0) {
        uint64_t mask = (UINT64_C(1) << remaining_bits) - 1;
        v[new_full_words] &= mask;
        new_full_words++; // keep that partial word
    }

    // Zero out all subsequent words up to the original length
    for (size_t i = new_full_words; i < orig_words; i++) {
        v[i] = 0;
    }
}

static int hqc_pke_encrypt(PROV_HQC_KEM_CTX *ctx, EVP_MD_CTX *md_ctx, uint64_t *u, uint64_t *v,
    HQC_KEY *key, uint64_t *m, uint8_t *theta)
{
    uint64_t h[VEC_SIZE(key->info->n, 64)];
    uint64_t s[VEC_SIZE(key->info->n, 64)];
    uint64_t r1[VEC_SIZE(key->info->n, 64)];
    uint64_t r2[VEC_SIZE(key->info->n, 64)];
    uint64_t e[VEC_SIZE(key->info->n, 64)];
    uint64_t tmp[VEC_SIZE(key->info->n, 64)];
    uint8_t domain = HQC_XOF_DOMAIN;

    memset(h, 0, VEC_SIZE(key->info->n, 8));
    memset(s, 0, VEC_SIZE(key->info->n, 8));
    memset(r1, 0, VEC_SIZE(key->info->n, 8));
    memset(r2, 0, VEC_SIZE(key->info->n, 8));
    memset(e, 0, VEC_SIZE(key->info->n, 8));
    memset(tmp, 0, VEC_SIZE(key->info->n, 8));
    memset(u, 0, VEC_SIZE(key->info->n, 8));
    memset(v, 0, VEC_SIZE(key->info->n, 8));

    /*
     * Get h and s vectors
     * implements hqc_ek_pke_from_string(h, s, ek_pke);
     */
    if (!EVP_DigestInit_ex2(md_ctx, ctx->shake, NULL))
        goto err;

    if (!EVP_DigestUpdate(md_ctx, key->ek, SEED_BYTES))
        goto err;

    if (!EVP_DigestUpdate(md_ctx, &domain, 1))
        goto err;

    /*
     * fetch h and s from ek
     */
    if (!EVP_DigestSqueeze(md_ctx, (uint8_t *)h, VEC_SIZE(key->info->n, 8)))
        goto err;

    h[VEC_SIZE(key->info->n, 64) - 1] &= VEC_BITMASK(key->info->n, 64);

    memcpy(s, key->ek + SEED_BYTES, VEC_SIZE(key->info->n, 8));

    /*
     * Init shake with theta
     */
    if (!EVP_DigestInit_ex2(md_ctx, ctx->shake, NULL))
        goto err;

    if (!EVP_DigestUpdate(md_ctx, theta, SEED_BYTES))
        goto err;

    if (!EVP_DigestUpdate(md_ctx, &domain, 1))
        goto err;

    /* we're going to squeeze the above in just a moment */

    // Generate re, e and r1
    vect_sample_fixed_weight2(md_ctx, key, r2, key->info->omega_r);
    vect_sample_fixed_weight2(md_ctx, key, e, key->info->omega_e);
    vect_sample_fixed_weight2(md_ctx, key, r1, key->info->omega_r);

    // Compute u = r1 + r2.h
    vect_mul(u, r2, h, key);
    vect_add(u, r1, u, VEC_SIZE(key->info->n, 64));

    // Compute v = C.encode(m)
    code_encode(key, v, m);

    // Compute v = C.encode(m) + Truncate(s.r2 + e)
    vect_mul(tmp, r2, s, key);
    vect_add(tmp, e, tmp, VEC_SIZE(key->info->n, 64));
    vect_truncate(tmp, key);
    vect_add(v, v, tmp, VEC_SIZE(key->info->n1n2, 64));

    return 1;
err:
    return 0;
}

static int hqc_kem_encapsulate(void *vctx, unsigned char *ctext, size_t *clen,
    unsigned char *shsec, size_t *slen)
{
    PROV_HQC_KEM_CTX *ctx = vctx;
    HQC_KEY *key = ctx->key;
    uint8_t entropy[48]; /* seed for the shake rng */
    EVP_MD_CTX *md_ctx = NULL;
    uint8_t domain = HQC_PRNG_DOMAIN_SEP;
    uint8_t m[key->info->security_bytes];
    uint8_t salt[key->info->salt_bytes];
    uint8_t k_theta[SEED_BYTES + key->info->shared_secret_bytes];
    uint8_t theta[SEED_BYTES];
    uint8_t hash_ek_kem[SEED_BYTES];
    uint64_t u[VEC_SIZE(key->info->n, 64)];
    uint64_t v[VEC_SIZE(key->info->n, 64)];
    unsigned int len = 0;

    if (ctext == NULL) {
        if (clen == NULL && slen == NULL)
            return 0;
        if (clen != NULL)
            *clen = VEC_SIZE(key->info->n, 8) + VEC_SIZE(key->info->n1n2, 8) + key->info->salt_bytes;
        if (slen != NULL)
            *slen = key->info->shared_secret_bytes;
        return 1;
    }

    md_ctx = EVP_MD_CTX_new();
    if (md_ctx == NULL)
        goto err;

    /*
     * Get some entropy to seed the prng below
     */
    if (!RAND_bytes_ex(PROV_LIBCTX_OF(ctx->provctx), entropy, 48, 0))
        goto err;

    /*
     * Initalize our shake alg as a prng
     */
    if (!EVP_DigestInit_ex2(md_ctx, ctx->shake, NULL))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, entropy, 48))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, &domain, 1))
        goto err;

    /*
     * Get some random data for our security bytes
     */
    if (!EVP_DigestSqueeze(md_ctx, (unsigned char *)m, key->info->security_bytes))
        goto err;

    if (!EVP_DigestSqueeze(md_ctx, (unsigned char *)salt, key->info->salt_bytes))
        goto err;

    /*
     * hash our ek key to produce our shared key
     */
    if (!EVP_DigestInit_ex2(md_ctx, ctx->sha3_256, NULL))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, key->ek, key->info->ek_size))
        goto err;
    domain = HQC_H_FCT_DOMAIN;
    if (!EVP_DigestUpdate(md_ctx, &domain, 1))
        goto err;
    memset(hash_ek_kem, 0, key->info->seed_len);
    if (!EVP_DigestFinal_ex(md_ctx, hash_ek_kem, &len))
        goto err;

    if (!EVP_DigestInit_ex2(md_ctx, ctx->sha3_512, NULL))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, hash_ek_kem, key->info->seed_len))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, m, key->info->security_bytes))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, salt, key->info->salt_bytes))
        goto err;
    domain = HQC_G_FCT_DOMAIN;
    if (!EVP_DigestUpdate(md_ctx, &domain, 1))
        goto err;
    memset(k_theta, 0, key->info->seed_len);
    if (!EVP_DigestFinal_ex(md_ctx, k_theta, &len))
        goto err;

    memcpy(theta, k_theta + key->info->seed_len, key->info->seed_len);

    hqc_pke_encrypt(ctx, md_ctx, u, v, key, (uint64_t *)m, theta);

    memcpy(ctext, u, VEC_SIZE(key->info->n, 8));
    memcpy(ctext + VEC_SIZE(key->info->n, 8), v, VEC_SIZE(key->info->n1n2, 8));
    memcpy(ctext + VEC_SIZE(key->info->n, 8) + VEC_SIZE(key->info->n1n2, 8),
        salt, key->info->salt_bytes);
    memcpy(shsec, k_theta, key->info->shared_secret_bytes);
    *slen = key->info->shared_secret_bytes;
    return 1;
err:
    EVP_MD_CTX_free(md_ctx);
    return 0;
}

static int hqc_kem_decapsulate(void *vctx, uint8_t *shsec, size_t *slen,
    const uint8_t *ctext, size_t clen)
{
    /* PROV_HQC_KEM_CTX *ctx = vctx; */
    return 0;
}

const OSSL_DISPATCH ossl_hqc_kem_asym_kem_functions[] = {
    { OSSL_FUNC_KEM_NEWCTX, (OSSL_FUNC)hqc_kem_newctx },
    { OSSL_FUNC_KEM_ENCAPSULATE_INIT, (OSSL_FUNC)hqc_kem_encapsulate_init },
    { OSSL_FUNC_KEM_ENCAPSULATE, (OSSL_FUNC)hqc_kem_encapsulate },
    { OSSL_FUNC_KEM_DECAPSULATE_INIT, (OSSL_FUNC)hqc_kem_decapsulate_init },
    { OSSL_FUNC_KEM_DECAPSULATE, (OSSL_FUNC)hqc_kem_decapsulate },
    { OSSL_FUNC_KEM_FREECTX, (OSSL_FUNC)hqc_kem_freectx },
    { OSSL_FUNC_KEM_SET_CTX_PARAMS, (OSSL_FUNC)hqc_kem_set_ctx_params },
    { OSSL_FUNC_KEM_SETTABLE_CTX_PARAMS, (OSSL_FUNC)hqc_kem_settable_ctx_params },
    OSSL_DISPATCH_END
};
