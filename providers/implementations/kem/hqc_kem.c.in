/*
 * Copyright 2025 The OpenSSL Project Authors. All Rights Reserved.
 *
 * Licensed under the Apache License 2.0 (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 */
{-
use OpenSSL::paramnames qw(produce_param_decoder);
-}

#include <string.h>
#include <openssl/crypto.h>
#include <openssl/evp.h>
#include <openssl/core_dispatch.h>
#include <openssl/core_names.h>
#include <openssl/params.h>
#include <openssl/err.h>
#include <openssl/proverr.h>
#include "crypto/hqc_kem.h"
#include "internal/cryptlib.h"
#include "prov/provider_ctx.h"
#include "prov/implementations.h"
#include "prov/securitycheck.h"
#include "prov/providercommon.h"

static OSSL_FUNC_kem_newctx_fn hqc_kem_newctx;
static OSSL_FUNC_kem_freectx_fn hqc_kem_freectx;
static OSSL_FUNC_kem_encapsulate_init_fn hqc_kem_encapsulate_init;
static OSSL_FUNC_kem_encapsulate_fn hqc_kem_encapsulate;
static OSSL_FUNC_kem_decapsulate_init_fn hqc_kem_decapsulate_init;
static OSSL_FUNC_kem_decapsulate_fn hqc_kem_decapsulate;
static OSSL_FUNC_kem_set_ctx_params_fn hqc_kem_set_ctx_params;
static OSSL_FUNC_kem_settable_ctx_params_fn hqc_kem_settable_ctx_params;

typedef struct {
    HQC_KEY *key;
    EVP_MD *shake;
    void *provctx;
    int op;
} PROV_HQC_KEM_CTX;

static void *hqc_kem_newctx(void *provctx)
{
    PROV_HQC_KEM_CTX *ctx;

    if ((ctx = OPENSSL_malloc(sizeof(*ctx))) == NULL)
        return NULL;

    ctx->key = NULL;
    ctx->provctx = provctx;
    return ctx;
}

static void hqc_kem_freectx(void *vctx)
{
    PROV_HQC_KEM_CTX *ctx = vctx;

    EVP_MD_free(ctx->shake);
    OPENSSL_free(ctx);
}

static int hqc_kem_init(void *vctx, int op, void *key,
                        const OSSL_PARAM params[])
{
    PROV_HQC_KEM_CTX *ctx = vctx;

    if (!ossl_prov_is_running())
        return 0;
    ctx->key = key;
    ctx->op = op;
    ctx->shake = EVP_MD_fetch(PROV_LIBCTX_OF(ctx->provctx), "SHAKE256", NULL);
    if (ctx->shake == NULL)
        goto err;

    return hqc_kem_set_ctx_params(vctx, params);
err:
    hqc_kem_freectx(ctx);
    return 0;
}

static int hqc_kem_encapsulate_init(void *vctx, void *vkey,
                                    const OSSL_PARAM params[])
{
    return hqc_kem_init(vctx, EVP_PKEY_OP_ENCAPSULATE, key, params);
}

static int hqc_kem_decapsulate_init(void *vctx, void *vkey,
                                    const OSSL_PARAM params[])
{
    return hqc_kem_init(vctx, EVP_PKEY_OP_DECAPSULATE, key, params);
}

{- produce_param_decoder('hqc_kem_set_ctx_params',
                         ); -}

static int hqc_kem_set_ctx_params(void *vctx, const OSSL_PARAM params[])
{
    PROV_HQC_KEM_CTX *ctx = vctx;
    struct hqc_kem_set_ctx_params_st p;

    if (ctx == NULL || !hqc_kem_set_ctx_params_decoder(params, &p))
        return 0;

    return 1;
}

static const OSSL_PARAM *hqc_kem_settable_ctx_params(ossl_unused void *vctx,
                                                     ossl_unused void *provctx)
{
    return hqc_kem_set_ctx_params_list;
}

static int hqc_kem_encapsulate(void *vctx, unsigned char *ctext, size_t *clen,
                              unsigned char *shsec, size_t *slen)
{
    PROV_HQC_KEM_CTX *ctx = vctx;
    HQC_KEY *key = ctx->key;
    uint8_t entropy[48]; /* seed for the shake rng */
    EVP_MD_CTX *md_ctx = NULL;
    uint8_t domain = HQC_PRNG_DOMAIN_SEP;
    uint8_t m[key->info->security_bytes];
    uint8_t salt[key->info->salt_bytes];

    md_ctx = EVP_MD_CTX_new();
    if (md_ctx == NULL)
        goto err;

    /*
     * Get some entropy to seed the prng below
     */
    if (!RAND_bytes_ex(PROV_LIBCTX_OF(ctx->provctx), entropy, 48))
        goto err;

    /*
     * Initalize our shake alg as a prng
     */
    if (!EVP_DigestInit_ex2(md_ctx, ctx->shake, NULL))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, entropy, 48))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, &domain, 1))
        goto err;

    /*
     * Get some random data for our security bytes
     */
    if (!EVP_DigestSqueeze(md_ctx, (unsigned char *)m, key->info->security_bytes))
        goto err;

    if (!EVP_DigestSqueeze(md_ctx, (unsigned char *)salt, key->info->salt_bytes))
        goto err;

    return 1;
err:
    EVP_MD_CTX_free(md_ctx);
    return 0;
}

static int hqc_kem_decapsulate(void *vctx, uint8_t *shsec, size_t *slen,
                               const uint8_t *ctext, size_t clen)
{
    PROV_HQC_KEM_CTX *ctx = vctx;
    HQC_KEY *key = ctx->key;
    return 0;
}

const OSSL_DISPATCH ossl_hqc_kem_asym_kem_functions[] = {
    { OSSL_FUNC_KEM_NEWCTX, (OSSL_FUNC) hqc_kem_newctx },
    { OSSL_FUNC_KEM_ENCAPSULATE_INIT, (OSSL_FUNC) hqc_kem_encapsulate_init },
    { OSSL_FUNC_KEM_ENCAPSULATE, (OSSL_FUNC) hqc_kem_encapsulate },
    { OSSL_FUNC_KEM_DECAPSULATE_INIT, (OSSL_FUNC) hqc_kem_decapsulate_init },
    { OSSL_FUNC_KEM_DECAPSULATE, (OSSL_FUNC) hqc_kem_decapsulate },
    { OSSL_FUNC_KEM_FREECTX, (OSSL_FUNC) hqc_kem_freectx },
    { OSSL_FUNC_KEM_SET_CTX_PARAMS, (OSSL_FUNC) hqc_kem_set_ctx_params },
    { OSSL_FUNC_KEM_SETTABLE_CTX_PARAMS, (OSSL_FUNC) hqc_kem_settable_ctx_params },
    OSSL_DISPATCH_END
};
