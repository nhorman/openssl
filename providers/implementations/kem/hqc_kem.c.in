/*
 * Copyright 2025 The OpenSSL Project Authors. All Rights Reserved.
 *
 * Licensed under the Apache License 2.0 (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 */

/* clang-format off */
{-
use OpenSSL::paramnames qw(produce_param_decoder);
-}
/* clang-format on */

#include <string.h>
#include <openssl/crypto.h>
#include <openssl/evp.h>
#include <openssl/core_dispatch.h>
#include <openssl/core_names.h>
#include <openssl/params.h>
#include <openssl/rand.h>
#include <openssl/err.h>
#include <openssl/proverr.h>
#include "crypto/hqc_kem.h"
#include "internal/cryptlib.h"
#include "prov/provider_ctx.h"
#include "prov/implementations.h"
#include "prov/securitycheck.h"
#include "prov/providercommon.h"

static OSSL_FUNC_kem_newctx_fn hqc_kem_newctx;
static OSSL_FUNC_kem_freectx_fn hqc_kem_freectx;
static OSSL_FUNC_kem_encapsulate_init_fn hqc_kem_encapsulate_init;
static OSSL_FUNC_kem_encapsulate_fn hqc_kem_encapsulate;
static OSSL_FUNC_kem_decapsulate_init_fn hqc_kem_decapsulate_init;
static OSSL_FUNC_kem_decapsulate_fn hqc_kem_decapsulate;
static OSSL_FUNC_kem_set_ctx_params_fn hqc_kem_set_ctx_params;
static OSSL_FUNC_kem_settable_ctx_params_fn hqc_kem_settable_ctx_params;

/**
 * @def HQC_PRNG_DOMAIN_SEP
 * @brief Domain separation constant for the HQC PRNG (Pseudo-Random
 *        Number Generator).
 *
 * Used to distinguish the PRNG context from other cryptographic
 * primitives in HQC operations, ensuring unique input domains for
 * hashing or seed expansion functions.
 */
#define HQC_PRNG_DOMAIN_SEP 0

/** @def HQC_H_FCT_DOMAIN
 *  @brief Domain separator for the H(·) function in HQC.
 */
#define HQC_H_FCT_DOMAIN 1

/** @def HQC_G_FCT_DOMAIN
 *  @brief Domain separator for the G(·) function in HQC.
 */
#define HQC_G_FCT_DOMAIN 0

/** @def HQC_XOF_DOMAIN
 *  @brief Domain separator for the XOF function in HQC.
 */
#define HQC_XOF_DOMAIN 1

/** @def HQC_J_FCT_DOMAIN
 *  @brief Domain separator for the J(·) function in HQC.
 */
#define HQC_J_FCT_DOMAIN 3

/**
 * @def KARATSUBA_THRESHOLD
 * @brief Threshold for switching to the Karatsuba multiplication
 *        algorithm.
 *
 * When the operand size (in coefficients, words, or bits—depending on
 * context) exceeds this threshold, the Karatsuba multiplication method
 * is used instead of the standard (schoolbook) multiplication.
 *
 * This value balances performance and overhead: smaller sizes use
 * simpler algorithms to reduce setup cost, while larger sizes benefit
 * from Karatsuba’s reduced asymptotic complexity.
 */
#define KARATSUBA_THRESHOLD 16

typedef struct {
    HQC_KEY *key;
    EVP_MD *shake;
    EVP_MD *sha3_256;
    EVP_MD *sha3_512;
    void *provctx;
    int op;
} PROV_HQC_KEM_CTX;

static void *hqc_kem_newctx(void *provctx)
{
    PROV_HQC_KEM_CTX *ctx;

    if ((ctx = OPENSSL_malloc(sizeof(*ctx))) == NULL)
        return NULL;

    ctx->key = NULL;
    ctx->provctx = provctx;
    return ctx;
}

static void hqc_kem_freectx(void *vctx)
{
    PROV_HQC_KEM_CTX *ctx = vctx;

    EVP_MD_free(ctx->shake);
    EVP_MD_free(ctx->sha3_256);
    EVP_MD_free(ctx->sha3_512);
    OPENSSL_free(ctx);
}

static int hqc_kem_init(void *vctx, int op, void *key,
    const OSSL_PARAM params[])
{
    PROV_HQC_KEM_CTX *ctx = vctx;

    if (!ossl_prov_is_running())
        return 0;
    ctx->key = key;
    ctx->op = op;
    ctx->shake = EVP_MD_fetch(PROV_LIBCTX_OF(ctx->provctx), "SHAKE256", NULL);
    if (ctx->shake == NULL)
        goto err;

    ctx->sha3_256 = EVP_MD_fetch(PROV_LIBCTX_OF(ctx->provctx), "SHA3-256", NULL);
    if (ctx->sha3_256 == NULL)
        goto err;

    ctx->sha3_512 = EVP_MD_fetch(PROV_LIBCTX_OF(ctx->provctx), "SHA3-512", NULL);
    if (ctx->sha3_512 == NULL)
        goto err;

    return hqc_kem_set_ctx_params(vctx, params);
err:
    hqc_kem_freectx(ctx);
    return 0;
}

static int hqc_kem_encapsulate_init(void *vctx, void *vkey,
    const OSSL_PARAM params[])
{
    return hqc_kem_init(vctx, EVP_PKEY_OP_ENCAPSULATE, vkey, params);
}

static int hqc_kem_decapsulate_init(void *vctx, void *vkey,
    const OSSL_PARAM params[])
{
    return hqc_kem_init(vctx, EVP_PKEY_OP_DECAPSULATE, vkey, params);
}

/* clang-format off */
{- produce_param_decoder('hqc_kem_set_ctx_params',
                         ); -}
/* clang-format on */

static int hqc_kem_set_ctx_params(void *vctx, const OSSL_PARAM params[])
{
    PROV_HQC_KEM_CTX *ctx = vctx;
    struct hqc_kem_set_ctx_params_st p;

    if (ctx == NULL || !hqc_kem_set_ctx_params_decoder(params, &p))
        return 0;

    return 1;
}

static const OSSL_PARAM *hqc_kem_settable_ctx_params(ossl_unused void *vctx,
    ossl_unused void *provctx)
{
    return hqc_kem_set_ctx_params_list;
}

static inline uint32_t compare_u32(const uint32_t v1, const uint32_t v2)
{
    return 1 ^ (((v1 - v2) | (v2 - v1)) >> 31);
}

static int vect_sample_fixed_weight2(EVP_MD_CTX *md_ctx, HQC_KEY *key, uint64_t *v, uint16_t weight)
{
    uint32_t support[key->info->omega_r];
    uint32_t rand_u32[key->info->omega_r];
    uint32_t index_tab[key->info->omega_r];
    uint64_t bit_tab[key->info->omega_r];

    memset(support, 0, sizeof(support));
    memset(rand_u32, 0, sizeof(rand_u32));
    memset(index_tab, 0, sizeof(index_tab));
    memset(bit_tab, 0, sizeof(bit_tab));

    if (!EVP_DigestSqueeze(md_ctx, (unsigned char *)rand_u32, weight * 4))
        return 0;

    for (size_t i = 0; i < weight; ++i) {
        uint64_t buff = rand_u32[i];
        support[i] = i + ((buff * (key->info->n - i)) >> 32);
    }

    for (int32_t i = (weight - 1); i-- > 0;) {
        uint32_t found = 0;

        for (size_t j = i + 1; j < weight; ++j) {
            found |= compare_u32(support[j], support[i]);
        }

        uint32_t mask = -found;
        support[i] = (mask & i) ^ (~mask & support[i]);
    }

    for (size_t i = 0; i < weight; i++) {
        index_tab[i] = support[i] >> 6;
        int32_t pos = support[i] & 0x3f;
        bit_tab[i] = ((uint64_t)1) << pos;
    }

    uint64_t val = 0;
    for (uint32_t i = 0; i < VEC_SIZE(key->info->n, 64); i++) {
        val = 0;
        for (uint32_t j = 0; j < weight; j++) {
            uint32_t tmp = i - index_tab[j];
            int val1 = 1 ^ ((tmp | -tmp) >> 31);
            uint64_t mask = -val1;
            val |= (bit_tab[j] & mask);
        }
        v[i] |= val;
    }

    return 1;
}

/**
 * @brief Performs polynomial multiplication using the schoolbook method
 *        over GF(2).
 *
 * This function multiplies two binary polynomials represented as
 * 64-bit word arrays and stores the 128-bit result in the output
 * buffer. Each input operand is treated as a polynomial with binary
 * coefficients, and multiplication is performed modulo 2 (XOR-based
 * accumulation).
 *
 * @param r
 *   Pointer to the output buffer of size @c 2 * n 64-bit words. The
 *   buffer is zero-initialized at the start of the operation.
 *
 * @param a
 *   Pointer to the first input operand (multiplicand), represented as
 *   an array of @c n 64-bit words.
 *
 * @param b
 *   Pointer to the second input operand (multiplier), represented as
 *   an array of @c n 64-bit words.
 *
 * @param n
 *   Number of 64-bit words in each input operand.
 *
 * @details
 *   - Implements classic “schoolbook” polynomial multiplication in
 *     GF(2)[x].
 *   - Each bit of @p a is examined; if the bit is set, the polynomial
 *     @p b is XORed into the result @p r shifted by the bit’s position.
 *   - Bit-level shifts and XOR operations are used instead of
 *     arithmetic multiplication or addition.
 *   - Handles bit shifts across word boundaries, propagating high bits
 *     into the next word.
 *
 * @note
 *   - The result buffer @p r must be large enough to hold 2 × n 64-bit
 *     words.
 *   - Operates entirely in constant-time bitwise logic (no conditional
 *     branches on secret data).
 *   - This is a reference (non-optimized) implementation suitable for
 *     small operand sizes or as a fallback when Karatsuba or FFT-based
 *     multiplication is not beneficial.
 */
static void schoolbook_mul(uint64_t *r, const uint64_t *a, const uint64_t *b, size_t n)
{
    size_t i, j, base;
    int bit, sh, inv;
    uint64_t mask, ai;

    memset(r, 0, 2 * n * sizeof(uint64_t));
    for (i = 0; i < n; i++) {
        ai = a[i];
        for (bit = 0; bit < 64; bit++) {
            mask = -((ai >> bit) & 1ULL);
            base = i;
            sh = bit;
            inv = 64 - sh;
            if (sh == 0) {
                for (j = 0; j < n; j++) {
                    r[base + j] ^= b[j] & mask;
                }
            } else {
                for (j = 0; j < n; j++) {
                    r[base + j] ^= (b[j] << sh) & mask;
                    r[base + j + 1] ^= (b[j] >> inv) & mask;
                }
            }
        }
    }
}

/**
 * @brief Performs polynomial multiplication using the recursive
 *        Karatsuba algorithm over GF(2).
 *
 * This function computes the product of two binary polynomials
 * represented as arrays of 64-bit words, using the Karatsuba
 * divide-and-conquer algorithm for improved efficiency over the
 * classical schoolbook method. Multiplication and accumulation are
 * performed with XOR operations, as arithmetic is carried out in GF(2).
 *
 * @param r
 *   Pointer to the output buffer of size @c 2 * n 64-bit words, which
 *   will hold the resulting product. The buffer is cleared before
 *   accumulation.
 *
 * @param a
 *   Pointer to the first input operand (multiplicand), represented as
 *   an array of @c n 64-bit words.
 *
 * @param b
 *   Pointer to the second input operand (multiplier), represented as
 *   an array of @c n 64-bit words.
 *
 * @param n
 *   Number of 64-bit words in each input operand.
 *
 * @param tmp_buffer
 *   Pointer to a temporary buffer used for storing intermediate
 *   results and recursive workspace. The buffer must be large enough
 *   to accommodate several subproducts and temporary vectors.
 *
 * @details
 *   - For small operand sizes (@c n ≤ @c KARATSUBA_THRESHOLD), the
 *     function falls back to @c schoolbook_mul() for simplicity.
 *   - The operands are split into low and high halves:
 *     @f$a = a_0 + x^m a_1@f$, @f$b = b_0 + x^m b_1@f$.
 *   - The recursive Karatsuba formulation computes:
 *       - @c z0 = a0 * b0  (low product)
 *       - @c z2 = a1 * b1  (high product)
 *       - @c zmid = (a0 + a1) * (b0 + b1)
 *     and combines them via:
 *       @f$r = z0 + ((zmid ⊕ z0 ⊕ z2) << m) + (z2 << 2m)@f$.
 *   - XOR replaces addition to represent modular arithmetic in GF(2).
 *
 * @note
 *   - The algorithm runs in approximately O(n^1.585) time, offering
 *     better asymptotic performance than the quadratic schoolbook
 *     method for large n.
 *   - All arithmetic is constant-time with respect to data values,
 *     minimizing side-channel leakage.
 *   - Ensure @p tmp_buffer is sufficiently large; insufficient space
 *     may cause memory corruption.
 *   - Used internally for HQC finite-field and polynomial arithmetic
 *     operations where efficiency is critical.
 */
static void karatsuba_mul(uint64_t *r, const uint64_t *a, const uint64_t *b,
    size_t n, uint64_t *tmp_buffer)
{
    if (n <= KARATSUBA_THRESHOLD) {
        schoolbook_mul(r, a, b, n);
        return;
    }

    size_t m = n >> 1;
    size_t n0 = m;
    size_t n1 = n - m;

    /* take successive chunks of tmp_buffer for each intermediate result */
    uint64_t *z0 = tmp_buffer; /* low-half product, size 2*n words */
    uint64_t *z2 = z0 + 2 * n; /* high-half product, size 2*n words */
    uint64_t *zmid = z2 + 2 * n; /* middle product, size 2*n words */

    /* ta and tb hold the sums of low and high halves: */
    /* ta[i] = a0[i] XOR a1[i], tb[i] = b0[i] XOR b1[i] for i < n1 */
    uint64_t *ta = zmid + 2 * n;
    uint64_t *tb = ta + n;

    /* buffer for child recursions */
    uint64_t *child_buffer = tmp_buffer + 8 * n;

    /* 1) low * low */
    karatsuba_mul(z0, a, b, n0, child_buffer);

    /* 2) high * high */
    karatsuba_mul(z2, a + m, b + m, n1, child_buffer);

    /* 3) (a0+a1)*(b0+b1) */
    for (size_t i = 0; i < n1; i++) {
        uint64_t loa = (i < n0 ? a[i] : 0);
        uint64_t lob = (i < n0 ? b[i] : 0);
        ta[i] = loa ^ a[m + i];
        tb[i] = lob ^ b[m + i];
    }
    karatsuba_mul(zmid, ta, tb, n1, child_buffer);

    /* 4) assemble into r */
    memset(r, 0, 2 * n * sizeof(uint64_t));
    for (size_t i = 0; i < 2 * n0; i++)
        r[i] ^= z0[i];
    for (size_t i = 0; i < 2 * n1; i++)
        r[2 * m + i] ^= z2[i];
    for (size_t i = 0; i < 2 * n1; i++) {
        uint64_t z0i = (i < 2 * n0 ? z0[i] : 0);
        uint64_t z2i = (i < 2 * n1 ? z2[i] : 0);
        uint64_t mid = zmid[i] ^ z0i ^ z2i;
        r[m + i] ^= mid;
    }
}

static void reduce(uint64_t *out, const uint64_t *a, const HQC_VARIANT_INFO *info)
{
    for (size_t i = 0; i < VEC_SIZE(info->n, 64); i++) {
        uint64_t r = a[i + VEC_SIZE(info->n, 64) - 1] >> (info->n & 0x3F);
        uint64_t carry = a[i + VEC_SIZE(info->n, 64)] << (64 - (info->n & 0x3F));
        out[i] = a[i] ^ r ^ carry;
    }
    out[VEC_SIZE(info->n, 64) - 1] &= VEC_BITMASK(info->n, 64);
}

static void vect_mul(uint64_t *out, const uint64_t *a, const uint64_t *b, const HQC_KEY *key)
{
    uint64_t unreduced[2 * VEC_SIZE(key->info->n, 64)];
    uint64_t tmp_buffer[16 * VEC_SIZE(key->info->n, 64)];

    karatsuba_mul(unreduced, a, b, VEC_SIZE(key->info->n, 64), tmp_buffer);

    reduce(out, unreduced, key->info);
}

/**
 * @brief Adds two vectors
 *
 * @param[out] o Pointer to an array that is the result
 * @param[in] v1 Pointer to an array that is the first vector
 * @param[in] v2 Pointer to an array that is the second vector
 * @param[in] size Integer that is the size of the vectors
 */
void vect_add(uint64_t *o, const uint64_t *v1, const uint64_t *v2, uint32_t size)
{
    for (uint32_t i = 0; i < size; ++i) {
        o[i] = v1[i] ^ v2[i];
    }
}

static void gf_carryless_mul(uint8_t *c, uint8_t a, uint8_t b)
{
    uint16_t h = 0, l = 0, g, u[4];
    u[0] = 0;
    u[1] = b & ((1UL << 7) - 1UL);
    u[2] = u[1] << 1;
    u[3] = u[2] ^ u[1];

    g = 0;
    uint16_t tmp1 = a & 3;

    for (int i = 0; i < 4; i++) {
        uint32_t tmp2 = tmp1 - i;
        g ^= (u[i] & -(1 - ((tmp2 | -tmp2) >> 31)));
    }

    l = g;
    h = 0;

    for (uint8_t i = 2; i < 8; i += 2) {
        g = 0;
        uint16_t tmp3 = (a >> i) & 3;
        for (int j = 0; j < 4; ++j) {
            uint32_t tmp2 = tmp3 - j;
            g ^= (u[j] & -(1 - ((tmp2 | -tmp2) >> 31)));
        }

        l ^= g << i;
        h ^= g >> (8 - i);
    }

    uint16_t mask = (-((b >> 7) & 1));
    l ^= ((a << 7) & mask);
    h ^= ((a >> (1)) & mask);

    c[0] = l;
    c[1] = h;
}

static uint16_t gf_reduce(uint16_t x)
{
    uint64_t mod;
    const int reduction_steps = 2; // For deg(x) = 2 * (8 - 1) = 14, reduce twice to bring degree < 8
    const size_t gf_reduction_tap_count = 3; // Number of feedback positions
    static const uint8_t gf_reduction_taps[] = { 4, 3, 2 };

    for (int i = 0; i < reduction_steps; ++i) {
        mod = x >> 8; // Extract upper bits
        x &= (1 << 8) - 1; // Keep lower bits
        x ^= mod; // Pre-XOR with no shift

        uint16_t z1 = 0;
        for (size_t j = gf_reduction_tap_count; j; --j) {
            uint16_t z2 = gf_reduction_taps[j - 1];
            uint16_t dist = z2 - z1;
            mod <<= dist;
            x ^= mod;
            z1 = z2;
        }
    }

    return x;
}

static uint16_t gf_mul(uint16_t a, uint16_t b)
{
    uint8_t c[2] = { 0, 0 };
    uint16_t tmp;

    gf_carryless_mul(c, (uint8_t)a, (uint8_t)b);
    tmp = (uint16_t)(c[0] ^ (c[1] << 8));
    return gf_reduce(tmp);
}

uint16_t gf_square(HQC_KEY *key, uint16_t a)
{
    uint32_t b = a;
    uint32_t s = b & 1;
    for (size_t i = 1; i < key->info->m; ++i) {
        b <<= 1;
        s ^= b & (1 << 2 * i);
    }

    return gf_reduce(s);
}

uint16_t gf_inverse(HQC_KEY *key, uint16_t a)
{
    uint16_t inv = a;
    uint16_t tmp1, tmp2;

    inv = gf_square(key, a); /* a^2 */
    tmp1 = gf_mul(inv, a); /* a^3 */
    inv = gf_square(key, inv); /* a^4 */
    tmp2 = gf_mul(inv, tmp1); /* a^7 */
    tmp1 = gf_mul(inv, tmp2); /* a^11 */
    inv = gf_mul(tmp1, inv); /* a^15 */
    inv = gf_square(key, inv); /* a^30 */
    inv = gf_square(key, inv); /* a^60 */
    inv = gf_square(key, inv); /* a^120 */
    inv = gf_mul(inv, tmp2); /* a^127 */
    inv = gf_square(key, inv); /* a^254 */
    return inv;
}

typedef union {
    uint8_t u8[16]; /**< Byte-wise access (16 bytes) */
    uint32_t u32[4]; /**< Word-wise access (4 32-bit words) */
} rm_codeword_t;

typedef int16_t rm_expanded_cdw[128];

/**
 * @def BIT0MASK(x)
 * @brief Broadcast the least significant bit of \p x to a 32-bit mask.
 *
 * @param x  An integer expression; only bit 0 is examined.
 * @return   A 32-bit value of all ones (if \p x&1 == 1) or all zeros (if \p x&1 == 0).
 */
#define BIT0MASK(x) (int32_t)(-((x) & 1))

static void encode(rm_codeword_t *word, int32_t message)
{
    int32_t first_word;

    first_word = BIT0MASK(message >> 7);

    first_word ^= BIT0MASK(message >> 0) & 0xaaaaaaaa;
    first_word ^= BIT0MASK(message >> 1) & 0xcccccccc;
    first_word ^= BIT0MASK(message >> 2) & 0xf0f0f0f0;
    first_word ^= BIT0MASK(message >> 3) & 0xff00ff00;
    first_word ^= BIT0MASK(message >> 4) & 0xffff0000;

    word->u32[0] = first_word;

    first_word ^= BIT0MASK(message >> 5);
    word->u32[1] = first_word;
    first_word ^= BIT0MASK(message >> 6);
    word->u32[3] = first_word;
    first_word ^= BIT0MASK(message >> 5);
    word->u32[2] = first_word;
    return;
}

static void code_encode(HQC_KEY *key, uint64_t *em, const uint64_t *m)
{
    uint64_t tmp[VEC_SIZE(key->info->n1, 8)];
    uint16_t tmp_g[key->info->g];
    uint8_t msg_bytes[key->info->k];
    uint8_t cdw_bytes[key->info->n1];
    size_t i, j, k;
    uint8_t gate_value = 0;
    uint8_t *msg_array;
    rm_codeword_t *code_array = (rm_codeword_t *)em;

    memset(tmp, 0, sizeof(tmp));
    memset(msg_bytes, 0, sizeof(msg_bytes));
    memset(cdw_bytes, 0, sizeof(cdw_bytes));
    memset(tmp_g, 0, sizeof(tmp_g));
    /*
     * Do a reed/solomon encoding of the message to the tmp variable
     */
    memcpy(msg_bytes, m, key->info->k);
    for (i = 0; i < key->info->k; ++i) {
        gate_value = msg_bytes[key->info->k - 1 - i] ^ cdw_bytes[key->info->n1 - key->info->k - 1];

        for (j = 0; j < key->info->g; ++j) {
            tmp_g[j] = gf_mul(gate_value, key->info->rs_coefs[j]);
        }

        for (k = key->info->n1 - key->info->k - 1; k; --k) {
            cdw_bytes[k] = cdw_bytes[k - 1] ^ tmp_g[k];
        }

        cdw_bytes[0] = tmp_g[0];
    }

    memcpy(cdw_bytes + key->info->n1 - key->info->k, msg_bytes, key->info->k);
    memcpy(tmp, cdw_bytes, key->info->n1);

    /*
     * Now reed-muller encode the tmp result to em
     */
    msg_array = (uint8_t *)tmp;
    for (size_t i = 0; i < VEC_SIZE(key->info->n1, 8); i++) {
        // fill entries i * VEC_SIZE(key->info->n2) to (i+1) * VEC_SIZE(key->info->n2, 128)
        int32_t pos = i * VEC_SIZE(key->info->n2, 128);
        // encode first word
        encode(&code_array[pos], msg_array[i]);
        // copy to other identical codewords
        for (size_t copy = 1; copy < VEC_SIZE(key->info->n2, 128); copy++) {
            memcpy(&code_array[pos + copy], &code_array[pos], sizeof(rm_codeword_t));
        }
    }
}

static void compute_fft_betas(HQC_KEY *key, uint16_t *betas)
{
    size_t i;
    for (i = 0; i < key->info->m - 1; ++i) {
        betas[i] = 1 << (key->info->m - 1 - i);
    }
}

static void compute_subset_sums(uint16_t *subset_sums, const uint16_t *set, uint16_t set_size)
{
    uint16_t i, j;
    subset_sums[0] = 0;

    for (i = 0; i < set_size; ++i) {
        for (j = 0; j < (1 << i); ++j) {
            subset_sums[(1 << i) + j] = set[i] ^ subset_sums[j];
        }
    }
}

static void radix(HQC_KEY *key, uint16_t *f0, uint16_t *f1, const uint16_t *f, uint32_t m_f);

static void radix_big(HQC_KEY *key, uint16_t *f0, uint16_t *f1, const uint16_t *f, uint32_t m_f)
{
    uint16_t Q[2 * (1 << (key->info->fft - 2)) + 1];
    uint16_t R[2 * (1 << (key->info->fft - 2)) + 1];

    uint16_t Q0[1 << (key->info->fft - 2)];
    uint16_t Q1[1 << (key->info->fft - 2)];
    uint16_t R0[1 << (key->info->fft - 2)];
    uint16_t R1[1 << (key->info->fft - 2)];

    size_t i, n;

    memset(Q, 0, sizeof(Q));
    memset(R, 0, sizeof(R));
    memset(Q0, 0, sizeof(Q0));
    memset(Q1, 0, sizeof(Q1));
    memset(R0, 0, sizeof(R0));
    memset(R1, 0, sizeof(R1));

    n = 1;
    n <<= (m_f - 2);
    memcpy(Q, f + 3 * n, 2 * n);
    memcpy(Q + n, f + 3 * n, 2 * n);
    memcpy(R, f, 4 * n);

    for (i = 0; i < n; ++i) {
        Q[i] ^= f[2 * n + i];
        R[n + i] ^= Q[i];
    }

    radix(key, Q0, Q1, Q, m_f - 1);
    radix(key, R0, R1, R, m_f - 1);

    memcpy(f0, R0, 2 * n);
    memcpy(f0 + n, Q0, 2 * n);
    memcpy(f1, R1, 2 * n);
    memcpy(f1 + n, Q1, 2 * n);
}

static void radix(HQC_KEY *key, uint16_t *f0, uint16_t *f1, const uint16_t *f, uint32_t m_f)
{
    switch (m_f) {
    case 4:
        f0[4] = f[8] ^ f[12];
        f0[6] = f[12] ^ f[14];
        f0[7] = f[14] ^ f[15];
        f1[5] = f[11] ^ f[13];
        f1[6] = f[13] ^ f[14];
        f1[7] = f[15];
        f0[5] = f[10] ^ f[12] ^ f1[5];
        f1[4] = f[9] ^ f[13] ^ f0[5];

        f0[0] = f[0];
        f1[3] = f[7] ^ f[11] ^ f[15];
        f0[3] = f[6] ^ f[10] ^ f[14] ^ f1[3];
        f0[2] = f[4] ^ f0[4] ^ f0[3] ^ f1[3];
        f1[1] = f[3] ^ f[5] ^ f[9] ^ f[13] ^ f1[3];
        f1[2] = f[3] ^ f1[1] ^ f0[3];
        f0[1] = f[2] ^ f0[2] ^ f1[1];
        f1[0] = f[1] ^ f0[1];
        break;
    case 3:
        f0[0] = f[0];
        f0[2] = f[4] ^ f[6];
        f0[3] = f[6] ^ f[7];
        f1[1] = f[3] ^ f[5] ^ f[7];
        f1[2] = f[5] ^ f[6];
        f1[3] = f[7];
        f0[1] = f[2] ^ f0[2] ^ f1[1];
        f1[0] = f[1] ^ f0[1];
        break;

    case 2:
        f0[0] = f[0];
        f0[1] = f[2] ^ f[3];
        f1[0] = f[1] ^ f0[1];
        f1[1] = f[3];
        break;

    case 1:
        f0[0] = f[0];
        f1[0] = f[1];
        break;

    default:
        radix_big(key, f0, f1, f, m_f);
        break;
    }
}

static void fft_rec(HQC_KEY *key, uint16_t *w, uint16_t *f, size_t f_coeffs,
    uint8_t m, uint32_t m_f, const uint16_t *betas)
{
    uint16_t f0[1 << (key->info->fft - 2)];
    uint16_t f1[1 << (key->info->fft - 2)];
    uint16_t gammas[key->info->m - 2];
    uint16_t deltas[key->info->m - 2];
    uint16_t gammas_sums[1 << (key->info->m - 2)];
    uint16_t u[1 << (key->info->m - 2)];
    uint16_t v[1 << (key->info->m - 2)];
    uint16_t tmp[key->info->m - (key->info->fft - 1)];

    uint16_t beta_m_pow;
    size_t i, j, k;
    size_t x;

    memset(f0, 0, sizeof(f0));
    memset(f1, 0, sizeof(f1));
    memset(gammas, 0, sizeof(gammas));
    memset(deltas, 0, sizeof(deltas));
    memset(u, 0, sizeof(u));
    memset(v, 0, sizeof(v));
    memset(tmp, 0, sizeof(tmp));

    // Step 1
    if (m_f == 1) {
        for (i = 0; i < m; ++i) {
            tmp[i] = gf_mul(betas[i], f[1]);
        }

        w[0] = f[0];
        x = 1;
        for (j = 0; j < m; ++j) {
            for (k = 0; k < x; ++k) {
                w[x + k] = w[k] ^ tmp[j];
            }
            x <<= 1;
        }

        return;
    }

    // Step 2: compute g
    if (betas[m - 1] != 1) {
        beta_m_pow = 1;
        x = 1;
        x <<= m_f;
        for (i = 1; i < x; ++i) {
            beta_m_pow = gf_mul(beta_m_pow, betas[m - 1]);
            f[i] = gf_mul(beta_m_pow, f[i]);
        }
    }

    // Step 3
    radix(key, f0, f1, f, m_f);

    // Step 4: compute gammas and deltas
    for (i = 0; i + 1 < m; ++i) {
        gammas[i] = gf_mul(betas[i], gf_inverse(key, betas[m - 1]));
        deltas[i] = gf_square(key, gammas[i]) ^ gammas[i];
    }

    // Compute gammas sums
    compute_subset_sums(gammas_sums, gammas, m - 1);

    // Step 5
    fft_rec(key, u, f0, (f_coeffs + 1) / 2, m - 1, m_f - 1, deltas);

    k = 1;
    k <<= ((m - 1) & 0xf); // &0xf is to let the compiler know that m-1 is small.
    if (f_coeffs <= 3) { // 3-coefficient polynomial f case: f1 is constant
        w[0] = u[0];
        w[k] = u[0] ^ f1[0];
        for (i = 1; i < k; ++i) {
            w[i] = u[i] ^ gf_mul(gammas_sums[i], f1[0]);
            w[k + i] = w[i] ^ f1[0];
        }
    } else {
        fft_rec(key, v, f1, f_coeffs / 2, m - 1, m_f - 1, deltas);

        // Step 6
        memcpy(w + k, v, 2 * k);
        w[0] = u[0];
        w[k] ^= u[0];
        for (i = 1; i < k; ++i) {
            w[i] = u[i] ^ gf_mul(gammas_sums[i], v[i]);
            w[k + i] ^= w[i];
        }
    }
}

static void fft(HQC_KEY *key, uint16_t *w, const uint16_t *f, size_t f_coeffs)
{
    uint16_t betas[key->info->m - 1];
    uint16_t betas_sums[1 << (key->info->m - 1)];
    uint16_t f0[1 << (key->info->fft - 1)];
    uint16_t f1[1 << (key->info->fft - 1)];
    uint16_t deltas[key->info->m - 1];
    uint16_t u[1 << (key->info->m - 1)];
    uint16_t v[1 << (key->info->m - 1)];
    size_t i, k;

    memset(betas, 0, sizeof(betas));
    memset(betas_sums, 0, sizeof(betas_sums));
    memset(f0, 0, sizeof(f0));
    memset(f1, 0, sizeof(f1));
    memset(deltas, 0, sizeof(deltas));
    memset(u, 0, sizeof(u));
    memset(v, 0, sizeof(v));

    // Follows Gao and Mateer algorithm
    compute_fft_betas(key, betas);

    // Step 1: PARAM_FFT > 1, nothing to do

    // Compute gammas sums
    compute_subset_sums(betas_sums, betas, key->info->m - 1);

    // Step 2: beta_m = 1, nothing to do

    // Step 3
    radix(key, f0, f1, f, key->info->fft);

    // Step 4: Compute deltas
    for (i = 0; i < key->info->m - 1; ++i) {
        deltas[i] = gf_square(key, betas[i]) ^ betas[i];
    }

    // Step 5
    fft_rec(key, u, f0, (f_coeffs + 1) / 2, key->info->m - 1, key->info->fft - 1, deltas);
    fft_rec(key, v, f1, f_coeffs / 2, key->info->m - 1, key->info->fft - 1, deltas);

    k = 1 << (key->info->m - 1);
    // Step 6, 7 and error polynomial computation
    memcpy(w + k, v, 2 * k);

    // Check if 0 is root
    w[0] = u[0];

    // Check if 1 is root
    w[k] ^= u[0];

    // Find other roots
    for (i = 1; i < k; ++i) {
        w[i] = u[i] ^ gf_mul(betas_sums[i], v[i]);
        w[k + i] ^= w[i];
    }
}

static void compute_fft_betas(HQC_KEY *key, uint16_t *betas);
static void compute_subset_sums(uint16_t *subset_sums, const uint16_t *set, uint16_t set_size);

#define PARAM_GF_MUL_ORDER 255

/**
 * Logarithm of elements of GF(2^8) to the base alpha (root of 1 + x^2 + x^3 + x^4 + x^8).
 * The logarithm of 0 is set to 0 by convention.
 */
static const uint16_t gf_log[256] = {
    0, 0, 1, 25, 2, 50, 26, 198, 3, 223, 51, 238, 27, 104, 199, 75, 4, 100, 224, 14, 52, 141,
    239, 129, 28, 193, 105, 248, 200, 8, 76, 113, 5, 138, 101, 47, 225, 36, 15, 33, 53, 147, 142, 218,
    240, 18, 130, 69, 29, 181, 194, 125, 106, 39, 249, 185, 201, 154, 9, 120, 77, 228, 114, 166, 6, 191,
    139, 98, 102, 221, 48, 253, 226, 152, 37, 179, 16, 145, 34, 136, 54, 208, 148, 206, 143, 150, 219, 189,
    241, 210, 19, 92, 131, 56, 70, 64, 30, 66, 182, 163, 195, 72, 126, 110, 107, 58, 40, 84, 250, 133,
    186, 61, 202, 94, 155, 159, 10, 21, 121, 43, 78, 212, 229, 172, 115, 243, 167, 87, 7, 112, 192, 247,
    140, 128, 99, 13, 103, 74, 222, 237, 49, 197, 254, 24, 227, 165, 153, 119, 38, 184, 180, 124, 17, 68,
    146, 217, 35, 32, 137, 46, 55, 63, 209, 91, 149, 188, 207, 205, 144, 135, 151, 178, 220, 252, 190, 97,
    242, 86, 211, 171, 20, 42, 93, 158, 132, 60, 57, 83, 71, 109, 65, 162, 31, 45, 67, 216, 183, 123,
    164, 118, 196, 23, 73, 236, 127, 12, 111, 246, 108, 161, 59, 82, 41, 157, 85, 170, 251, 96, 134, 177,
    187, 204, 62, 90, 203, 89, 95, 176, 156, 169, 160, 81, 11, 245, 22, 235, 122, 117, 44, 215, 79, 174,
    213, 233, 230, 231, 173, 232, 116, 214, 244, 234, 168, 80, 88, 175
};

/**
 * Powers of the root alpha of 1 + x^2 + x^3 + x^4 + x^8.
 * The last two elements are needed by the gf_mul function
 * (for example if both elements to multiply are zero).
 */
static const uint16_t gf_exp[258] = {
    1, 2, 4, 8, 16, 32, 64, 128, 29, 58, 116, 232, 205, 135, 19, 38, 76, 152, 45, 90, 180, 117,
    234, 201, 143, 3, 6, 12, 24, 48, 96, 192, 157, 39, 78, 156, 37, 74, 148, 53, 106, 212, 181, 119,
    238, 193, 159, 35, 70, 140, 5, 10, 20, 40, 80, 160, 93, 186, 105, 210, 185, 111, 222, 161, 95, 190,
    97, 194, 153, 47, 94, 188, 101, 202, 137, 15, 30, 60, 120, 240, 253, 231, 211, 187, 107, 214, 177, 127,
    254, 225, 223, 163, 91, 182, 113, 226, 217, 175, 67, 134, 17, 34, 68, 136, 13, 26, 52, 104, 208, 189,
    103, 206, 129, 31, 62, 124, 248, 237, 199, 147, 59, 118, 236, 197, 151, 51, 102, 204, 133, 23, 46, 92,
    184, 109, 218, 169, 79, 158, 33, 66, 132, 21, 42, 84, 168, 77, 154, 41, 82, 164, 85, 170, 73, 146,
    57, 114, 228, 213, 183, 115, 230, 209, 191, 99, 198, 145, 63, 126, 252, 229, 215, 179, 123, 246, 241, 255,
    227, 219, 171, 75, 150, 49, 98, 196, 149, 55, 110, 220, 165, 87, 174, 65, 130, 25, 50, 100, 200, 141,
    7, 14, 28, 56, 112, 224, 221, 167, 83, 166, 81, 162, 89, 178, 121, 242, 249, 239, 195, 155, 43, 86,
    172, 69, 138, 9, 18, 36, 72, 144, 61, 122, 244, 245, 247, 243, 251, 235, 203, 139, 11, 22, 44, 88,
    176, 125, 250, 233, 207, 131, 27, 54, 108, 216, 173, 71, 142, 1, 2, 4
};

static void fft_retrieve_error_poly(HQC_KEY *key, uint8_t *error, const uint16_t *w)
{
    uint16_t gammas[key->info->m - 1];
    uint16_t gammas_sums[1 << (key->info->m - 1)];
    uint16_t k;
    size_t i, index;

    memset(gammas, 0, sizeof(gammas));
    memset(gammas_sums, 0, sizeof(gammas));

    compute_fft_betas(key, gammas);
    compute_subset_sums(gammas_sums, gammas, key->info->m - 1);

    k = 1 << (key->info->m - 1);
    error[0] ^= 1 ^ ((uint16_t)-w[0] >> 15);
    error[0] ^= 1 ^ ((uint16_t)-w[k] >> 15);

    for (i = 1; i < k; ++i) {
        index = PARAM_GF_MUL_ORDER - gf_log[gammas_sums[i]];
        error[index] ^= 1 ^ ((uint16_t)-w[i] >> 15);

        index = PARAM_GF_MUL_ORDER - gf_log[gammas_sums[i] ^ 1];
        error[index] ^= 1 ^ ((uint16_t)-w[k + i] >> 15);
    }
}

static void expand_and_sum(rm_expanded_cdw *dest, rm_codeword_t src[], int32_t multiplicity)
{
    // start with the first copy
    for (int32_t part = 0; part < 4; part++) {
        for (int32_t bit = 0; bit < 32; bit++) {
            (*dest)[part * 32 + bit] = src[0].u32[part] >> bit & 1;
        }
    }
    // sum the rest of the copies
    for (int32_t copy = 1; copy < multiplicity; copy++) {
        for (int32_t part = 0; part < 4; part++) {
            for (int32_t bit = 0; bit < 32; bit++) {
                (*dest)[part * 32 + bit] += src[copy].u32[part] >> bit & 1;
            }
        }
    }
}

void hadamard(rm_expanded_cdw *src, rm_expanded_cdw *dst)
{
    // the passes move data:
    // src -> dst -> src -> dst -> src -> dst -> src -> dst
    // using p1 and p2 alternately
    rm_expanded_cdw *p1 = src;
    rm_expanded_cdw *p2 = dst;
    for (int32_t pass = 0; pass < 7; pass++) {
        for (int32_t i = 0; i < 64; i++) {
            (*p2)[i] = (*p1)[2 * i] + (*p1)[2 * i + 1];
            (*p2)[i + 64] = (*p1)[2 * i] - (*p1)[2 * i + 1];
        }
        // swap p1, p2 for next round
        rm_expanded_cdw *p3 = p1;
        p1 = p2;
        p2 = p3;
    }
}

int32_t find_peaks(rm_expanded_cdw *transform)
{
    int32_t peak_abs_value = 0;
    int32_t peak_value = 0;
    int32_t peak_pos = 0;
    for (int32_t i = 0; i < 128; i++) {
        // get absolute value
        int32_t t = (*transform)[i];
        int32_t pos_mask = -(t > 0);
        int32_t absolute = (pos_mask & t) | (~pos_mask & -t);
        peak_value = absolute > peak_abs_value ? t : peak_value;
        peak_pos = absolute > peak_abs_value ? i : peak_pos;
        peak_abs_value = absolute > peak_abs_value ? absolute : peak_abs_value;
    }
    // set bit 7
    peak_pos |= 128 * (peak_value > 0);
    return peak_pos;
}

void compute_syndromes(HQC_KEY *key, uint16_t *syndromes, uint8_t *cdw)
{
    for (size_t i = 0; i < 2 * key->info->delta; ++i) {
        for (size_t j = 1; j < key->info->n1; ++j) {
            syndromes[i] ^= gf_mul(cdw[j], *(key->info->alpha_ij_pow + ((i * 2) + (j - 1))));
        }
        syndromes[i] ^= cdw[0];
    }
}

static uint16_t compute_elp(HQC_KEY *key, uint16_t *sigma, const uint16_t *syndromes)
{
    uint16_t deg_sigma = 0;
    uint16_t deg_sigma_p = 0;
    uint16_t deg_sigma_copy = 0;
    uint16_t sigma_copy[key->info->delta + 1];
    uint16_t X_sigma_p[key->info->delta + 1];
    uint16_t pp = (uint16_t)-1; // 2*rho
    uint16_t d_p = 1;
    uint16_t d = syndromes[0];

    uint16_t mask1, mask2, mask12;
    uint16_t deg_X, deg_X_sigma_p;
    uint16_t dd;
    uint16_t mu;

    uint16_t i;

    memset(sigma_copy, 0, sizeof(sigma_copy));
    memset(X_sigma_p, 0, sizeof(X_sigma_p));
    X_sigma_p[1] = 1;

    sigma[0] = 1;
    for (mu = 0; (mu < (2 * key->info->delta)); ++mu) {
        // Save sigma in case we need it to update X_sigma_p
        memcpy(sigma_copy, sigma, 2 * key->info->delta);
        deg_sigma_copy = deg_sigma;

        dd = gf_mul(d, gf_inverse(key, d_p));

        for (i = 1; (i <= mu + 1) && (i <= key->info->delta); ++i) {
            sigma[i] ^= gf_mul(dd, X_sigma_p[i]);
        }

        deg_X = mu - pp;
        deg_X_sigma_p = deg_X + deg_sigma_p;

        // mask1 = 0xffff if(d != 0) and 0 otherwise
        mask1 = -((uint16_t)-d >> 15);

        // mask2 = 0xffff if(deg_X_sigma_p > deg_sigma) and 0 otherwise
        mask2 = -((uint16_t)(deg_sigma - deg_X_sigma_p) >> 15);

        // mask12 = 0xffff if the deg_sigma increased and 0 otherwise
        volatile uint16_t mask12__ = mask1 & mask2;
        mask12 = mask12__;
        deg_sigma ^= mask12 & (deg_X_sigma_p ^ deg_sigma);

        if (mu == (2 * key->info->delta - 1)) {
            break;
        }

        pp ^= mask12 & (mu ^ pp);
        d_p ^= mask12 & (d ^ d_p);
        for (i = key->info->delta; i; --i) {
            X_sigma_p[i] = (mask12 & sigma_copy[i - 1]) ^ (~mask12 & X_sigma_p[i - 1]);
        }

        deg_sigma_p ^= mask12 & (deg_sigma_copy ^ deg_sigma_p);
        d = syndromes[mu + 1];

        for (i = 1; (i <= mu + 1) && (i <= key->info->delta); ++i) {
            d ^= gf_mul(sigma[i], syndromes[mu + 1 - i]);
        }
    }

    return deg_sigma;
}

static void compute_roots(HQC_KEY *key, uint8_t *error, uint16_t *sigma)
{
    uint16_t w[1 << key->info->m];

    memset(w, 0, sizeof(w));

    fft(key, w, sigma, key->info->delta + 1);
    fft_retrieve_error_poly(key, error, w);
}

static void compute_z_poly(HQC_KEY *key, uint16_t *z, const uint16_t *sigma, const uint16_t degree, const uint16_t *syndromes)
{
    size_t i, j;
    uint16_t mask;

    z[0] = 1;

    for (i = 1; i < key->info->delta + 1; ++i) {
        mask = -((uint16_t)(i - degree - 1) >> 15);
        z[i] = mask & sigma[i];
    }

    z[1] ^= syndromes[0];

    for (i = 2; i <= key->info->delta; ++i) {
        mask = -((uint16_t)(i - degree - 1) >> 15);
        z[i] ^= mask & syndromes[i - 1];

        for (j = 1; j < i; ++j) {
            z[i] ^= mask & gf_mul(sigma[j], syndromes[i - j - 1]);
        }
    }
}

static void compute_error_values(HQC_KEY *key, uint16_t *error_values,
    const uint16_t *z, const uint8_t *error)
{
    uint16_t beta_j[key->info->delta];
    uint16_t e_j[key->info->delta];
    uint16_t delta_counter;
    uint16_t delta_real_value;
    uint16_t found;
    uint16_t mask1;
    uint16_t mask2;
    uint16_t tmp1;
    uint16_t tmp2;
    uint16_t inverse;
    uint16_t inverse_power_j;

    memset(beta_j, 0, sizeof(beta_j));
    memset(e_j, 0, sizeof(e_j));

    // Compute the beta_{j_i} page 31 of the documentation
    delta_counter = 0;
    for (size_t i = 0; i < key->info->n1; i++) {
        found = 0;
        mask1 = (uint16_t)(-((int32_t)error[i]) >> 31); // error[i] != 0
        for (size_t j = 0; j < key->info->delta; j++) {
            mask2 = ~((uint16_t)(-((int32_t)j ^ delta_counter) >> 31)); // j == delta_counter
            beta_j[j] += mask1 & mask2 & gf_exp[i];
            found += mask1 & mask2 & 1;
        }
        delta_counter += found;
    }
    delta_real_value = delta_counter;

    // Compute the e_{j_i} page 31 of the documentation
    for (size_t i = 0; i < key->info->delta; ++i) {
        tmp1 = 1;
        tmp2 = 1;
        inverse = gf_inverse(key, beta_j[i]);
        inverse_power_j = 1;

        for (size_t j = 1; j <= key->info->delta; ++j) {
            inverse_power_j = gf_mul(inverse_power_j, inverse);
            tmp1 ^= gf_mul(inverse_power_j, z[j]);
        }
        for (size_t k = 1; k < key->info->delta; ++k) {
            tmp2 = gf_mul(tmp2, (1 ^ gf_mul(inverse, beta_j[(i + k) % key->info->delta])));
        }
        mask1 = (uint16_t)(((int16_t)i - delta_real_value) >> 15); // i < delta_real_value
        e_j[i] = mask1 & gf_mul(tmp1, gf_inverse(key, tmp2));
    }

    // Place the delta e_{j_i} values at the right coordinates of the output vector
    delta_counter = 0;
    for (size_t i = 0; i < key->info->n1; ++i) {
        found = 0;
        mask1 = (uint16_t)(-((int32_t)error[i]) >> 31); // error[i] != 0
        for (size_t j = 0; j < key->info->delta; j++) {
            mask2 = ~((uint16_t)(-((int32_t)j ^ delta_counter) >> 31)); // j == delta_counter
            error_values[i] += mask1 & mask2 & e_j[j];
            found += mask1 & mask2 & 1;
        }
        delta_counter += found;
    }
}

static void correct_errors(HQC_KEY *key, uint8_t *cdw, const uint16_t *error_values)
{
    for (size_t i = 0; i < key->info->n1; ++i)
        cdw[i] ^= error_values[i];
}

static void code_decode(HQC_KEY *key, uint64_t *m, const uint64_t *em)
{
    uint64_t tmp[VEC_SIZE(key->info->n1, 64)];
    uint8_t *message_array = (uint8_t *)tmp;
    rm_codeword_t *code_array = (rm_codeword_t *)em;
    rm_expanded_cdw expanded;
    rm_expanded_cdw transform;
    uint8_t cdw_bytes[key->info->n1];
    uint16_t syndromes[2 * key->info->delta];
    uint16_t sigma[1 << key->info->fft];
    uint8_t error[1 << key->info->m];
    uint16_t z[key->info->n1];
    uint16_t error_values[key->info->n1];
    uint16_t deg;

    memset(tmp, 0, sizeof(tmp));
    memset(cdw_bytes, 0, sizeof(cdw_bytes));
    memset(syndromes, 0, sizeof(syndromes));
    memset(sigma, 0, sizeof(sigma));
    memset(error, 0, sizeof(error));
    memset(z, 0, sizeof(z));
    memset(error_values, 0, sizeof(error_values));

    /*
     * Reed Muller decode
     */
    for (size_t i = 0; i < VEC_SIZE(key->info->n1, 8); i++) {
        // collect the codewords
        expand_and_sum(&expanded, &code_array[i * VEC_SIZE(key->info->n2, 128)],
            VEC_SIZE(key->info->n2, 128));
        // apply hadamard transform
        hadamard(&expanded, &transform);
        // fix the first entry to get the half Hadamard transform
        transform[0] -= 64 * VEC_SIZE(key->info->n2, 128);
        // finish the decoding
        message_array[i] = find_peaks(&transform);
    }

    /*
     * Reed Solomon decode
     */
    memcpy(cdw_bytes, tmp, key->info->n1);
    compute_syndromes(key, syndromes, cdw_bytes);
    deg = compute_elp(key, sigma, syndromes);
    compute_roots(key, error, sigma);
    compute_z_poly(key, z, sigma, deg, syndromes);
    compute_error_values(key, error_values, z, error);
    correct_errors(key, cdw_bytes, error_values);

    /*
     * Copy the plaintext to the message pointer
     */
    memcpy(m, cdw_bytes + (key->info->g - 1), key->info->k);
}

void vect_truncate(uint64_t *v, HQC_KEY *key)
{
    size_t orig_words = (key->info->n + 63) / 64;
    size_t new_full_words = key->info->n1n2 / 64;
    size_t remaining_bits = key->info->n1n2 % 64;

    // Mask the last word if there's a partial word
    if (remaining_bits > 0) {
        uint64_t mask = (UINT64_C(1) << remaining_bits) - 1;
        v[new_full_words] &= mask;
        new_full_words++; // keep that partial word
    }

    // Zero out all subsequent words up to the original length
    for (size_t i = new_full_words; i < orig_words; i++) {
        v[i] = 0;
    }
}

static int hqc_pke_encrypt(PROV_HQC_KEM_CTX *ctx, EVP_MD_CTX *md_ctx, uint64_t *u, uint64_t *v,
    HQC_KEY *key, uint64_t *m, uint8_t *theta)
{
    uint64_t h[VEC_SIZE(key->info->n, 64)];
    uint64_t s[VEC_SIZE(key->info->n, 64)];
    uint64_t r1[VEC_SIZE(key->info->n, 64)];
    uint64_t r2[VEC_SIZE(key->info->n, 64)];
    uint64_t e[VEC_SIZE(key->info->n, 64)];
    uint64_t tmp[VEC_SIZE(key->info->n, 64)];
    uint8_t domain = HQC_XOF_DOMAIN;

    memset(h, 0, sizeof(h));
    memset(s, 0, sizeof(s));
    memset(r1, 0, sizeof(r1));
    memset(r2, 0, sizeof(r2));
    memset(e, 0, sizeof(e));
    memset(tmp, 0, sizeof(tmp));

    /*
     * Get h and s vectors
     * implements hqc_ek_pke_from_string(h, s, ek_pke);
     */
    if (!EVP_DigestInit_ex2(md_ctx, ctx->shake, NULL))
        goto err;

    if (!EVP_DigestUpdate(md_ctx, key->ek, SEED_BYTES))
        goto err;

    if (!EVP_DigestUpdate(md_ctx, &domain, 1))
        goto err;

    /*
     * fetch h and s from ek
     */
    if (!EVP_DigestSqueeze(md_ctx, (uint8_t *)h, VEC_SIZE(key->info->n, 8)))
        goto err;

    h[VEC_SIZE(key->info->n, 64) - 1] &= VEC_BITMASK(key->info->n, 64);

    memcpy(s, key->ek + SEED_BYTES, VEC_SIZE(key->info->n, 8));

    /*
     * Init shake with theta
     */
    if (!EVP_DigestInit_ex2(md_ctx, ctx->shake, NULL))
        goto err;

    if (!EVP_DigestUpdate(md_ctx, theta, SEED_BYTES))
        goto err;

    if (!EVP_DigestUpdate(md_ctx, &domain, 1))
        goto err;

    /* we're going to squeeze the above in just a moment */

    // Generate re, e and r1
    vect_sample_fixed_weight2(md_ctx, key, r2, key->info->omega_r);
    vect_sample_fixed_weight2(md_ctx, key, e, key->info->omega_e);
    vect_sample_fixed_weight2(md_ctx, key, r1, key->info->omega_r);

    // Compute u = r1 + r2.h
    vect_mul(u, r2, h, key);
    vect_add(u, r1, u, VEC_SIZE(key->info->n, 64));

    // Compute v = C.encode(m)
    code_encode(key, v, m);

    // Compute v = C.encode(m) + Truncate(s.r2 + e)
    vect_mul(tmp, r2, s, key);
    vect_add(tmp, e, tmp, VEC_SIZE(key->info->n, 64));
    vect_truncate(tmp, key);
    vect_add(v, v, tmp, VEC_SIZE(key->info->n1n2, 64));

    return 1;
err:
    return 0;
}

static int hqc_kem_encapsulate(void *vctx, unsigned char *ctext, size_t *clen,
    unsigned char *shsec, size_t *slen)
{
    PROV_HQC_KEM_CTX *ctx = vctx;
    HQC_KEY *key = ctx->key;
    uint8_t entropy[48]; /* seed for the shake rng */
    EVP_MD_CTX *md_ctx = NULL;
    uint8_t domain = HQC_PRNG_DOMAIN_SEP;
    uint8_t m[key->info->security_bytes];
    uint8_t salt[key->info->salt_bytes];
    uint8_t k_theta[SEED_BYTES + key->info->shared_secret_bytes];
    uint8_t theta[SEED_BYTES];
    uint8_t hash_ek_kem[SEED_BYTES];
    uint64_t u[VEC_SIZE(key->info->n, 64)];
    uint64_t v[VEC_SIZE(key->info->n, 64)];
    unsigned int len = 0;

    if (ctext == NULL) {
        if (clen == NULL && slen == NULL)
            return 0;
        if (clen != NULL)
            *clen = VEC_SIZE(key->info->n, 8) + VEC_SIZE(key->info->n1n2, 8) + key->info->salt_bytes;
        if (slen != NULL)
            *slen = key->info->shared_secret_bytes;
        return 1;
    }

    memset(m, 0, sizeof(m));
    memset(salt, 0, sizeof(salt));
    memset(k_theta, 0, sizeof(k_theta));
    memset(theta, 0, sizeof(theta));
    memset(hash_ek_kem, 0, sizeof(hash_ek_kem));
    memset(u, 0, sizeof(u));
    memset(v, 0, sizeof(v));

    md_ctx = EVP_MD_CTX_new();
    if (md_ctx == NULL)
        goto err;

    /*
     * Get some entropy to seed the prng below
     */
    if (!RAND_bytes_ex(PROV_LIBCTX_OF(ctx->provctx), entropy, 48, 0))
        goto err;

    /*
     * Initalize our shake alg as a prng
     */
    if (!EVP_DigestInit_ex2(md_ctx, ctx->shake, NULL))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, entropy, 48))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, &domain, 1))
        goto err;

    /*
     * Get some random data for our security bytes
     */
    if (!EVP_DigestSqueeze(md_ctx, (unsigned char *)m, key->info->security_bytes))
        goto err;

    if (!EVP_DigestSqueeze(md_ctx, (unsigned char *)salt, key->info->salt_bytes))
        goto err;

    /*
     * hash our ek key to produce our shared key
     */
    if (!EVP_DigestInit_ex2(md_ctx, ctx->sha3_256, NULL))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, key->ek, key->info->ek_size))
        goto err;
    domain = HQC_H_FCT_DOMAIN;
    if (!EVP_DigestUpdate(md_ctx, &domain, 1))
        goto err;
    memset(hash_ek_kem, 0, key->info->seed_len);
    if (!EVP_DigestFinal_ex(md_ctx, hash_ek_kem, &len))
        goto err;

    if (!EVP_DigestInit_ex2(md_ctx, ctx->sha3_512, NULL))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, hash_ek_kem, key->info->seed_len))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, m, key->info->security_bytes))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, salt, key->info->salt_bytes))
        goto err;
    domain = HQC_G_FCT_DOMAIN;
    if (!EVP_DigestUpdate(md_ctx, &domain, 1))
        goto err;
    memset(k_theta, 0, key->info->seed_len);
    if (!EVP_DigestFinal_ex(md_ctx, k_theta, &len))
        goto err;

    memcpy(theta, k_theta + key->info->seed_len, key->info->seed_len);

    hqc_pke_encrypt(ctx, md_ctx, u, v, key, (uint64_t *)m, theta);

    memcpy(ctext, u, VEC_SIZE(key->info->n, 8));
    memcpy(ctext + VEC_SIZE(key->info->n, 8), v, VEC_SIZE(key->info->n1n2, 8));
    memcpy(ctext + VEC_SIZE(key->info->n, 8) + VEC_SIZE(key->info->n1n2, 8),
        salt, key->info->salt_bytes);
    memcpy(shsec, k_theta, key->info->shared_secret_bytes);
    *slen = key->info->shared_secret_bytes;
    return 1;
err:
    EVP_MD_CTX_free(md_ctx);
    return 0;
}

static int xof_get_bytes(EVP_MD_CTX *xof_ctx, uint8_t *output, uint32_t output_size)
{
    const uint8_t bsize = sizeof(uint64_t);
    const uint8_t remainder = output_size % bsize;
    uint8_t tmp[sizeof(uint64_t)];

    if (!EVP_DigestSqueeze(xof_ctx, output, output_size - remainder))
        return 0;
    if (remainder != 0) {
        if (!EVP_DigestSqueeze(xof_ctx, tmp, bsize))
            return 0;
        output += output_size - remainder;
        for (uint8_t i = 0; i < remainder; i++) {
            output[i] = tmp[i];
        }
    }

    return 1;
}

static uint32_t barrett_reduce(uint32_t x, const HQC_VARIANT_INFO *info)
{
    uint64_t q = ((uint64_t)x * info->n_mu) >> 32;
    uint32_t r = x - (uint32_t)(q * info->n);
    uint32_t reduce_flag = (((r - info->n) >> 31) ^ 1);
    uint32_t mask = -reduce_flag;
    r -= mask & info->n;
    return r;
}

static int hqc_sample_xof(EVP_MD_CTX *md_ctx, uint64_t *vec, const HQC_VARIANT_INFO *info)
{
    uint32_t support[info->omega_r];
    size_t random_bytes_size = 3 * info->omega;
    uint8_t rand_bytes[3 * info->omega_r];
    uint8_t inc;
    size_t i, j, k;
    uint32_t index_tab[info->omega_r];
    uint64_t bit_tab[info->omega_r];
    int32_t pos;
    uint64_t val;
    uint32_t tmp;
    int val1;
    uint64_t mask;

    memset(support, 0, info->omega_r * sizeof(uint32_t));
    memset(rand_bytes, 0, 3 * info->omega_r);
    memset(index_tab, 0, info->omega_r * sizeof(uint32_t));
    memset(bit_tab, 0, info->omega_r * sizeof(uint64_t));

    i = 0;
    j = random_bytes_size;
    while (i < info->omega) {
        do {
            if (j == random_bytes_size) {
                if (!xof_get_bytes(md_ctx, rand_bytes, random_bytes_size))
                    return 0;
                j = 0;
            }
            support[i] = ((uint32_t)rand_bytes[j++]) << 16;
            support[i] |= ((uint32_t)rand_bytes[j++]) << 8;
            support[i] |= rand_bytes[j++];
        } while (support[i] >= info->rej_threshold);

        support[i] = barrett_reduce(support[i], info);

        inc = 1;
        for (k = 0; k < i; k++) {
            if (support[k] == support[i])
                inc = 0;
        }
        i += inc;
    }

    for (i = 0; i < info->omega; i++) {
        index_tab[i] = support[i] >> 6;
        pos = support[i] & 0x3f;
        bit_tab[i] = ((uint64_t)1) << pos;
    }

    val = 0;
    for (i = 0; i < VEC_SIZE(info->n, 64); i++) {
        val = 0;
        for (j = 0; j < info->omega; j++) {
            tmp = i - index_tab[j];
            val1 = 1 ^ ((tmp | -tmp) >> 31);
            mask = -val1;
            val |= (bit_tab[j] & mask);
        }
        vec[i] |= val;
    }

    return 1;
}

static uint8_t hqc_pke_decrypt(uint64_t *m, HQC_KEY *key,
    PROV_HQC_KEM_CTX *pctx, uint64_t *u, uint64_t *v)
{
    uint64_t y[VEC_SIZE(key->info->n, 64)];
    uint64_t tmp1[VEC_SIZE(key->info->n, 64)];
    uint64_t tmp2[VEC_SIZE(key->info->n, 64)];
    EVP_MD_CTX *ctx = EVP_MD_CTX_new();
    uint8_t result = 0;

    uint8_t domain = HQC_XOF_DOMAIN;
    if (ctx == NULL)
        return 0;

    memset(y, 0, VEC_SIZE(key->info->n, 64) * sizeof(uint64_t));
    memset(tmp1, 0, VEC_SIZE(key->info->n, 64) * sizeof(uint64_t));
    memset(tmp2, 0, VEC_SIZE(key->info->n, 64) * sizeof(uint64_t));

    if (!EVP_DigestInit_ex2(ctx, pctx->shake, NULL))
        goto err;

    if (!EVP_DigestUpdate(ctx, key->dk, key->info->seed_len))
        goto err;

    if (!EVP_DigestUpdate(ctx, &domain, 1))
        goto err;

    if (!hqc_sample_xof(ctx, y, key->info))
        goto err;

    vect_mul(tmp1, y, u, key);
    vect_truncate(tmp1, key);
    vect_add(tmp2, v, tmp1, VEC_SIZE(key->info->n1n2, 64));

    code_decode(key, m, tmp2);

    result = 1;

err:
    memset(y, 0, sizeof(y));
    memset(tmp1, 0, sizeof(tmp1));
    memset(tmp2, 0, sizeof(tmp2));
    EVP_MD_CTX_free(ctx);
    return result;
}

static uint8_t vect_compare(const uint8_t *v1, const uint8_t *v2, uint32_t size)
{
    uint16_t r = 0x0100;

    for (size_t i = 0; i < size; i++) {
        r |= v1[i] ^ v2[i];
    }

    return (r - 1) >> 8;
}

static int hqc_kem_decapsulate(void *vctx, uint8_t *shsec, size_t *slen,
    const uint8_t *ctext, size_t clen)
{
    PROV_HQC_KEM_CTX *ctx = vctx;
    HQC_KEY *key = ctx->key;
    HQC_KEY *peerkey = NULL;
    uint8_t ek_pke[key->info->ek_size];
    uint8_t dk_pke[key->info->seed_len];
    uint8_t sigma[key->info->security_bytes];
    uint8_t m_prime[key->info->security_bytes];
    uint8_t hash_ek_kem[key->info->seed_len];
    uint8_t K_theta_prime[key->info->shared_secret_bytes + key->info->seed_len];
    uint8_t K_bar[key->info->shared_secret_bytes];
    uint8_t theta_prime[key->info->seed_len];
    uint64_t u[VEC_SIZE(key->info->n, 64)];
    uint64_t u_prime[VEC_SIZE(key->info->n, 64)];
    uint64_t v[VEC_SIZE(key->info->n, 64)];
    uint64_t v_prime[VEC_SIZE(key->info->n, 64)];
    uint8_t salt[key->info->salt_bytes];
    uint8_t salt_prime[key->info->salt_bytes];
    uint8_t result;
    EVP_MD_CTX *md_ctx = NULL;
    int ret = 0;
    unsigned int len = 0;
    uint8_t domain;

    if (slen != NULL && *slen == 0) {
        *slen = key->info->shared_secret_bytes;
        return 1;
    }

    memset(ek_pke, 0, sizeof(ek_pke));
    memset(dk_pke, 0, sizeof(dk_pke));
    memset(sigma, 0, sizeof(sigma));
    memset(m_prime, 0, sizeof(m_prime));
    memset(hash_ek_kem, 0, sizeof(hash_ek_kem));
    memset(K_theta_prime, 0, sizeof(K_theta_prime));
    memset(K_bar, 0, sizeof(K_bar));
    memset(theta_prime, 0, sizeof(theta_prime));
    memset(u, 0, VEC_SIZE(key->info->n, 64) * sizeof(uint64_t));
    memset(u_prime, 0, sizeof(u_prime));
    memset(v, 0, VEC_SIZE(key->info->n, 64) * sizeof(uint64_t));
    memset(v_prime, 0, sizeof(v_prime));
    memset(salt, 0, sizeof(salt));
    memset(salt_prime, 0, sizeof(salt_prime));

    memcpy(ek_pke, key->dk, key->info->ek_size);
    memcpy(dk_pke, key->dk + key->info->ek_size, key->info->seed_len);
    memcpy(sigma, key->dk + key->info->ek_size + key->info->seed_len,
        key->info->security_bytes);

    memcpy(u, ctext, VEC_SIZE(key->info->n, 8));
    memcpy(v, ctext + VEC_SIZE(key->info->n, 8), VEC_SIZE(key->info->n1n2, 8));
    memcpy(salt, ctext + VEC_SIZE(key->info->n, 8) + VEC_SIZE(key->info->n1n2, 8),
        key->info->salt_bytes);

    result = hqc_pke_decrypt((uint64_t *)m_prime, key, ctx, u, v);

    /*
     * hash ek_pke to produce hash_ek_kem
     */
    md_ctx = EVP_MD_CTX_new();
    if (md_ctx == NULL)
        goto err;

    if (!EVP_DigestInit_ex2(md_ctx, ctx->sha3_256, NULL))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, ek_pke, key->info->shared_secret_bytes))
        goto err;
    domain = HQC_H_FCT_DOMAIN;
    if (!EVP_DigestUpdate(md_ctx, &domain, 1))
        goto err;
    if (!EVP_DigestFinal_ex(md_ctx, hash_ek_kem, &len))
        goto err;

    /*
     * produce K_theta
     */
    if (!EVP_DigestInit_ex2(md_ctx, ctx->sha3_256, NULL))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, hash_ek_kem, key->info->seed_len))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, m_prime, key->info->security_bytes))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, salt, key->info->salt_bytes))
        goto err;
    domain = HQC_G_FCT_DOMAIN;
    if (!EVP_DigestUpdate(md_ctx, &domain, 1))
        goto err;
    if (!EVP_DigestFinal_ex(md_ctx, K_theta_prime, &len))
        goto err;

    memcpy(shsec, K_theta_prime, key->info->shared_secret_bytes);
    memcpy(theta_prime, K_theta_prime + key->info->shared_secret_bytes, key->info->seed_len);
    peerkey = hqc_kem_new(key->info->type);
    memcpy(peerkey->ek, ek_pke, key->info->ek_size);
    if (!hqc_pke_encrypt(ctx, md_ctx, u_prime, v_prime, peerkey, (uint64_t *)m_prime, theta_prime))
        goto err;
    memcpy(salt_prime, salt, key->info->salt_bytes);

    /*
     * Compute K_bar
     */
    if (!EVP_DigestInit_ex2(md_ctx, ctx->sha3_256, NULL))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, hash_ek_kem, key->info->seed_len))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, sigma, key->info->security_bytes))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, u, VEC_SIZE(key->info->n, 8)))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, v, VEC_SIZE(key->info->n1n2, 8)))
        goto err;
    if (!EVP_DigestUpdate(md_ctx, salt, key->info->salt_bytes))
        goto err;
    domain = HQC_J_FCT_DOMAIN;
    if (!EVP_DigestUpdate(md_ctx, &domain, 1))
        goto err;
    if (!EVP_DigestFinal_ex(md_ctx, K_bar, &len))
        goto err;

    result |= vect_compare((uint8_t *)u, (uint8_t *)u_prime, VEC_SIZE(key->info->n, 8));
    result |= vect_compare((uint8_t *)v, (uint8_t *)v_prime, VEC_SIZE(key->info->n1n2, 8));
    result |= vect_compare(salt, salt_prime, key->info->salt_bytes);
    result -= 1;
    for (size_t i = 0; i < key->info->shared_secret_bytes; ++i)
        shsec[i] = (shsec[i] & result) ^ (K_bar[i] & ~result);

    ret = 1;
err:
    EVP_MD_CTX_free(md_ctx);
    return ret;
}

const OSSL_DISPATCH ossl_hqc_kem_asym_kem_functions[] = {
    { OSSL_FUNC_KEM_NEWCTX, (OSSL_FUNC)hqc_kem_newctx },
    { OSSL_FUNC_KEM_ENCAPSULATE_INIT, (OSSL_FUNC)hqc_kem_encapsulate_init },
    { OSSL_FUNC_KEM_ENCAPSULATE, (OSSL_FUNC)hqc_kem_encapsulate },
    { OSSL_FUNC_KEM_DECAPSULATE_INIT, (OSSL_FUNC)hqc_kem_decapsulate_init },
    { OSSL_FUNC_KEM_DECAPSULATE, (OSSL_FUNC)hqc_kem_decapsulate },
    { OSSL_FUNC_KEM_FREECTX, (OSSL_FUNC)hqc_kem_freectx },
    { OSSL_FUNC_KEM_SET_CTX_PARAMS, (OSSL_FUNC)hqc_kem_set_ctx_params },
    { OSSL_FUNC_KEM_SETTABLE_CTX_PARAMS, (OSSL_FUNC)hqc_kem_settable_ctx_params },
    OSSL_DISPATCH_END
};
