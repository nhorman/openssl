/*
 * Copyright 2025 The OpenSSL Project Authors. All Rights Reserved.
 *
 * Licensed under the Apache License 2.0 (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 */
{
    -use OpenSSL::paramnames qw(produce_param_decoder);
    -
}

#include <string.h>
#include <openssl/crypto.h>
#include <openssl/evp.h>
#include <openssl/core_dispatch.h>
#include <openssl/core_names.h>
#include <openssl/params.h>
#include <openssl/err.h>
#include <openssl/proverr.h>
#include "crypto/hqc_kem.h"
#include "internal/cryptlib.h"
#include "prov/provider_ctx.h"
#include "prov/implementations.h"
#include "prov/securitycheck.h"
#include "prov/providercommon.h"

static OSSL_FUNC_kem_newctx_fn hqc_kem_newctx;
static OSSL_FUNC_kem_freectx_fn hqc_kem_freectx;
static OSSL_FUNC_kem_encapsulate_init_fn hqc_kem_encapsulate_init;
static OSSL_FUNC_kem_encapsulate_fn hqc_kem_encapsulate;
static OSSL_FUNC_kem_decapsulate_init_fn hqc_kem_decapsulate_init;
static OSSL_FUNC_kem_decapsulate_fn hqc_kem_decapsulate;
static OSSL_FUNC_kem_set_ctx_params_fn hqc_kem_set_ctx_params;
static OSSL_FUNC_kem_settable_ctx_params_fn hqc_kem_settable_ctx_params;

typedef struct {
    HQC_KEY *key;
} PROV_HQC_KEM_CTX;

static void *hqc_kem_newctx(void *provctx)
{
    PROV_HQC_KEM_CTX *ctx;

    if ((ctx = OPENSSL_malloc(sizeof(*ctx))) == NULL)
        return NULL;

    ctx->key = NULL;
    return ctx;
}

static void hqc_kem_freectx(void *vctx)
{
    PROV_HQC_KEM_CTX *ctx = vctx;

    OPENSSL_free(ctx);
}

static int hqc_kem_init(void *vctx, int op, void *key,
    const OSSL_PARAM params[])
{
    PROV_HQC_KEM_CTX *ctx = vctx;

    if (!ossl_prov_is_running())
        return 0;
    ctx->key = key;
    return hqc_kem_set_ctx_params(vctx, params);
}

static int hqc_kem_encapsulate_init(void *vctx, void *vkey,
    const OSSL_PARAM params[])
{
    HQC_KEY *key = vkey;

    return hqc_kem_init(vctx, EVP_PKEY_OP_ENCAPSULATE, key, params);
}

static int hqc_kem_decapsulate_init(void *vctx, void *vkey,
    const OSSL_PARAM params[])
{
    HQC_KEY *key = vkey;

    return hqc_kem_init(vctx, EVP_PKEY_OP_DECAPSULATE, key, params);
}

{
    -produce_param_decoder('hqc_kem_set_ctx_params',
        ([ 'OSSL_KEM_PARAM_IKME', 'ikme', 'octet_string' ], ));
    -
}

static int hqc_kem_set_ctx_params(void *vctx, const OSSL_PARAM params[])
{
    PROV_HQC_KEM_CTX *ctx = vctx;
    struct hqc_kem_set_ctx_params_st p;

    if (ctx == NULL || !hqc_kem_set_ctx_params_decoder(params, &p))
        return 0;

    return 1;
}

static const OSSL_PARAM *hqc_kem_settable_ctx_params(ossl_unused void *vctx,
    ossl_unused void *provctx)
{
    return hqc_kem_set_ctx_params_list;
}

static int hqc_kem_encapsulate(void *vctx, unsigned char *ctext, size_t *clen,
    unsigned char *shsec, size_t *slen)
{
    PROV_HQC_KEM_CTX *ctx = vctx;
    HQC_KEY *key = ctx->key;
    return 0;
}

static int hqc_kem_decapsulate(void *vctx, uint8_t *shsec, size_t *slen,
    const uint8_t *ctext, size_t clen)
{
    PROV_HQC_KEM_CTX *ctx = vctx;
    HQC_KEY *key = ctx->key;
    return 0;
}

const OSSL_DISPATCH ossl_hqc_kem_asym_kem_functions[] = {
    { OSSL_FUNC_KEM_NEWCTX, (OSSL_FUNC)hqc_kem_newctx },
    { OSSL_FUNC_KEM_ENCAPSULATE_INIT, (OSSL_FUNC)hqc_kem_encapsulate_init },
    { OSSL_FUNC_KEM_ENCAPSULATE, (OSSL_FUNC)hqc_kem_encapsulate },
    { OSSL_FUNC_KEM_DECAPSULATE_INIT, (OSSL_FUNC)hqc_kem_decapsulate_init },
    { OSSL_FUNC_KEM_DECAPSULATE, (OSSL_FUNC)hqc_kem_decapsulate },
    { OSSL_FUNC_KEM_FREECTX, (OSSL_FUNC)hqc_kem_freectx },
    { OSSL_FUNC_KEM_SET_CTX_PARAMS, (OSSL_FUNC)hqc_kem_set_ctx_params },
    { OSSL_FUNC_KEM_SETTABLE_CTX_PARAMS, (OSSL_FUNC)hqc_kem_settable_ctx_params },
    OSSL_DISPATCH_END
};
